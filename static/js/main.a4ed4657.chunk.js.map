{"version":3,"sources":["store/universal-wallet/handlers.js","assets/logo.svg","pages/unextractable/Unextractable.js","../../src/constants/index.ts","../../src/crypto.ts","../../src/functions/jwkToBase58.ts","../../src/functions/fingerprintToDid.ts","../../src/functions/fromJwk.ts","../../src/functions/getMultibaseFromJwk.ts","../../src/Jws/Jws.ts","../../src/functions/base58KeyPairToJwk.ts","../../src/functions/getJwkTypeFromMultibase.ts","../../src/functions/toJwkPair.ts","../../src/KeyPair.ts","../../src/Jwe/Jwe.ts","../../src/functions/generate.ts","../../src/driver.ts","pages/unextractable/libp2p.js","../../src/types/index.ts","../../src/Jws/index.ts","../../src/getResolver.ts","../../src/getGet.ts","../../src/types/BlsCurveName.ts","../../src/functions/generateKeyPairs.ts","../../src/functions/keypairsToDidKey.ts","../../src/functions/toJsonWebKeyPair.ts","../../src/functions/fingerprintToJsonWebKeyPair.ts","../../src/functions/publicKeyJwkToDidKey.ts","../../src/Bls12381G1KeyPair.ts","../../src/Bls12381G2KeyPair.ts","../../src/Bls12381KeyPairs.ts","../../src/functions/keyToDidDoc.ts","../../bls12381/node_modules/@mattrglobal/bbs-signatures/lib sync","../../src/Cipher/crypto.ts","../../src/Cipher/algorithms/ecdhkdf.ts","../../src/Cipher/algorithms/classes/KeyEncryptionKey.ts","../../src/Cipher/algorithms/xc20p.ts","../../src/Cipher/DecryptTransformer.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Cipher/EncryptTransformer.ts","../../src/Cipher/getEpkGenerator.ts","../../src/keyUtils.ts","../../src/X25519KeyPair.ts","serviceWorker.js","store/universal-wallet/actions.js","store/universal-wallet/reducer.js","store/universal-wallet/redux.js","store/universal-wallet/index.js","store/universal-wallet/container.js","store/index.js","pages/home/ContentTypeToggle.js","pages/home/util.js","pages/home/VerticalTabs.js","pages/home/Home.js","pages/home/index.js","../../src/resolver.ts","pages/resolver/Resolver.js","pages/resolver/index.js","pages/index.js","pages/unextractable/index.js","components/ParticlesContainer/ParticlesContainer.js","pages/errors/404.js","store/create.js","index.js","../../bls12381/dist/index.js","store/history.js","pages/base/menu.js","pages/base/drawer.js","pages/base/base.js","../../src/EdDSA.ts","../../src/Ed25519KeyPair.ts","../../src/Secp256k1KeyPair.ts","../../src/ES256K.ts","components/Theme/Theme.js","../../bls12381/node_modules/@mattrglobal/node-bbs-signatures/lib sync","pages/unextractable/documentLoader.js","../node_modules/jspdf/dist sync"],"names":["getClient","wallet","a","_wallet","UniversalWallet2020","contents","entropy","find","c","type","ed25519Key","controller","id","split","x25519Key","VaultClient","fromDerivedContents","vaultEndpoint","Buffer","from","value","client","isContentPersisted","localContents","undefined","withHandlers","setUniversalWalletProp","payload","generateWallet","_seed","Error","generate","status","toggleLockStatus","password","unlock","lock","deleteWallet","importWallet","encryptedWallet","import","exportWallet","export","saveWallet","issueCredential","credential","options","issue","verifiableCredential","proveVerifiableCredential","prove","verifiablePresentation","syncVault","isSyncing","getWalletContents","console","log","message","content","data","JSON","parse","stringify","tableData","EdvClient","generateId","schema","doc","addWalletContent","module","exports","dbPromise","openDB","upgrade","db","createObjectStore","idbKeyval","key","get","val","put","window","peerCredentials","Unextractable","React","useState","yourNode","setYourNode","observedCredentials","setObservedCredentials","useEffect","usableKey","algorithm","name","namedCurve","keyUsages","crypto","subtle","generateKey","result","exportKey","privateKey","info","publicKey","publicKeyJwk","KeyPair","keyJson","toJsonWebKeyPair","JsonWebKey","keypair","signer","sign","createDetachedJws","hash","signature","alg","b64","crit","location","getLibp2p","libp2p","peerId","toB58String","suite","JsonWebSignature","date","issuanceDate","vcjs","issuer","credentialSubject","documentLoader","uri","res","room","Room","setInterval","broadcast","on","peer","messageJson","toString","verifyCredential","verified","error","variant","SUPPORTED_EC","crvToMulticodecPrefix","multicodecToJwkType","kty","crv","crvToJwsHashAlg","process","jwkToBase58","jwk","bs58","base64url","fingerprintToDid","fingerprint","methodName","fromJwk","publicKeyBase58","publicKeyBytes","prefix","buffer","Uint8Array","getMultibaseFromJwk","Jws","createJws","base58KeyPairToJwk","publicKeyBuffer","x","y","getJwkTypeFromMultibase","toJwkPair","_keypair","privateKeyBase58","staticImplements","this","args","fingerprintFromPublicKey","KeyPair_1","kp","generateEphemeralKeyPair","epkArgs","getEpkGenerator","kekFromEphemeralPeer","keyAgreementKey","epk","TypeError","ephemeralPublicKey","producerInfo","consumerInfo","secret","deriveKey","keyData","kek","kekFromStaticPeer","ephemeralKeyPair","staticPublicKey","epkPair","apu","apv","toKeyPair","exportPrivateKey","privateKeyJwk","privateKeyToSigner","verifier","verify","publicKeyToVerifier","deriveSecret","public","crvOrSize","d","resolve","getResolve","getGet","Libp2p","create","addresses","listen","modules","transport","Websockets","WebRTCStar","connEncryption","NOISE","streamMuxer","Mplex","peerDiscovery","Bootstrap","pubsub","Gossipsub","config","tag","enabled","list","start","toBeSigned","canonicalize","jws","header","toBeVerified","encodedHeader","encodedSignature","getVerificationMethod","contentType","externalKeyRepresentation","didKeyPairInstance","keyToDidDoc","did","verificationRelationships","verificationMethod","authentication","assertionMethod","capabilityInvocation","capabilityDelegation","keyAgreement","externalKeyRepresentation2","DidKeyPairClass","resolutionMetaData","accept","didUri","didDocument","didDocumentMetaData","didResolutionMetaData","url","BlsCurveName","generateKeyPairs","generateBls12381G1KeyPair","g1","generateBls12381G2KeyPair","g2","bls12381G1KeyPair","encode","secretKey","bls12381G2KeyPair","keypairsToDidKey","g1JsonWebKeyPair","g2JsonWebKeyPair","g1Buffer","toBuffer","g2Buffer","g1AndG2","concat","length","set","curveMap","G1","G2","jsonWebKeyPair","decode","fingerprintToJsonWebKeyPair","substring","slice","curveToMulticodecMap","publicKeyJwkToDidKey","Bls12381G1KeyPair","privateKeyBuffer","pop","fromFingerprint","opts","mattr","Bls12381G2KeyPair","Bls12381KeyPairs","g1KeyPair","g2KeyPair","indexOf","exportPrivate","push","vm","webpackEmptyContext","req","e","code","keys","input","ALGORITHM_ID","offset","dv","DataView","HASH_ALGORITHM","KEY_LENGTH","KeyEncryptionKey","wrapKey","unwrappedKey","wrappedKey","aeskw","bs64","unwrapKey","_wrappedKey","ciphertext","iv","additionalData","cek","cipher","encrypted","Symbol","iterator","asyncIterator","k0","getKid","copy","digest","privateKeyJwkFromPrivateKeyBase58","privateKeyBytes","_jwk","kid","publicKeyJwkFromPublicKeyBase58","privateKeyBase58FromPrivateKeyJwk","publicKeyBase58FromPublicKeyJwk","X25519KeyPair","keyUtils","pubkeyBytes","isAvailable","randomBytes","secureRandom","keyId","X25519KeyPair_1","fromEdKeyPair","ed25519KeyPair","convertPublicKeyToX25519","convertSecretKeyToX25519","verifyFingerprint","valid","fingerprintBuffer","_private","toJwk","remotePubkeyBytes","x25519","common","Boolean","hostname","match","createAction","handleActions","state","isSyncEnabled","connect","actions","reducer","container","compose","withRedux","router","connectRouter","history","ToggleButtons","onClick","alignment","setAlignment","ToggleButtonGroup","exclusive","onChange","event","newAlignment","aria-label","ToggleButton","disabled","generateEd25519","_keys","ed25519","generateX25519","keyPair","generateSecp256k1","secp256k1","generateBls12381","bls12381","generateP256","didKeyWebCrypto","generateP384","generateP521","TabPanel","props","children","index","other","role","hidden","aria-labelledby","Box","p","useStyles","makeStyles","theme","root","flexGrow","backgroundColor","palette","background","paper","display","tabs","borderRight","divider","Panel","onToggleRepresentation","onGenerate","Grid","spacing","item","sm","xs","Button","color","Typography","gutterBottom","VerticalTabs","classes","setState","setValue","refresh","handleGenerate","className","Tabs","orientation","newValue","map","opt","Tab","label","style","width","Home","prefixToDriverMap","z6Mk","z6LS","zUC7","z3tE","z5Tc","zQ3s","zXwp","zACH","zJss","didWebDriver","resolver","didUrl","encodedType","idchar","body","recover","then","Resolver","didDoc","setDidDoc","params","representation","routes","path","exact","component","ParticlesContainer","particles","line_linked","shadow","enable","blur","Fragment","zIndex","position","top","Component","NotFound","Theme","padding","href","appReducers","persistConfig","whitelist","storage","middlewares","thunk","routerMiddleware","store","createStore","persistReducer","combineReducers","rootReducer","composeWithDevTools","applyMiddleware","withReduxEnhancer","persistor","persistStore","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","require","createBrowserHistory","StyledMenu","withStyles","border","elevation","getContentAnchorEl","anchorOrigin","vertical","horizontal","transformOrigin","StyledMenuItem","primary","main","white","MenuItem","CustomizedMenus","anchorEl","setAnchorEl","IconButton","aria-controls","aria-haspopup","currentTarget","keepMounted","open","onClose","ListItemIcon","fontSize","ListItemText","DrawerContent","List","ListItem","button","appBar","drawer","transition","transitions","easing","sharp","duration","leavingScreen","appBarShift","marginLeft","enteringScreen","menuButton","marginRight","hide","flexShrink","whiteSpace","drawerOpen","drawerClose","overflowX","breakpoints","up","toolbar","alignItems","justifyContent","mixins","MiniDrawer","useTheme","setOpen","CssBaseline","AppBar","clsx","Toolbar","edge","src","logo","alt","title","height","Drawer","direction","Divider","privateKeyBuf","Ed25519KeyPair","publicNode","equals","toX25519KeyPair","signatureUInt8Array","privateKeyJwkFromPrivateKeyHex","privateKeyHex","keyto","publicKeyJwkFromPublicKeyHex","publicKeyHex","keyBin","privateKeyHexFromJwk","publicKeyHexFromJwk","uncompressedPublicKey","compressed","privateKeyUInt8ArrayFromJwk","publicKeyUInt8ArrayFromJwk","publicKeyBase58FromPublicKeyHex","privateKeyBase58FromPrivateKeyHex","privateKeyPem","publicKeyPem","Secp256k1KeyPair","_generate","messageHashUInt8Array","sigObj","toHex","font1","font2","font3","createMuiTheme","splashImage","light","lighten","dark","darken","secondary","typography","useNextVariants","fontFamily","join","h1","fontWeight","h2","h3","h4","textTransform","letterSpacing","h5","h6","subtitle1","subtitle2","body1","body2","caption","overline","overrides","MuiInput","MuiInputLabel","MuiAppBar","MuiButton","contained","boxShadow","golem","documentLoaderFactory","pluginFactory","build","contexts","W3C_Decentralized_Identifiers","W3C_Verifiable_Credentials","W3ID_Security_Vocabulary","addContext","addResolver","webCryptoDriver","buildDocumentLoader"],"mappings":"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","file":"static/js/main.a4ed4657.chunk.js","sourcesContent":["import { withHandlers } from \"recompose\";\nimport { EdvClient } from \"edv-client\";\nimport { UniversalWallet2020, VaultClient } from \"@transmute/universal-wallet\";\n\n// correct horse battery staple\n\nconst getClient = async (wallet) => {\n  let _wallet = new UniversalWallet2020(wallet.contents);\n  const entropy = _wallet.contents.find((c) => {\n    return c.type === \"Entropy\";\n  });\n  const ed25519Key = _wallet.contents.find((c) => {\n    return c.type === \"Ed25519VerificationKey2018\";\n  });\n  ed25519Key.controller = ed25519Key.id.split(\"#\")[0];\n  const x25519Key = _wallet.contents.find((c) => {\n    return c.type === \"X25519KeyAgreementKey2019\";\n  });\n  x25519Key.controller = x25519Key.id.split(\"#\")[0];\n  let client = await VaultClient.fromDerivedContents(\n    wallet.vaultEndpoint,\n    ed25519Key,\n    x25519Key,\n    Buffer.from(entropy.value, \"hex\")\n  );\n  return client;\n};\n\nconst isContentPersisted = (localContents, id) => {\n  return (\n    localContents.find((c) => {\n      return c.id === id;\n    }) !== undefined\n  );\n};\n\nexport default withHandlers({\n  setUniversalWalletProp: ({ setUniversalWalletProp }) => (payload) => {\n    setUniversalWalletProp(payload);\n  },\n  generateWallet: ({ setUniversalWalletProp }) => async (_seed) => {\n    if (!_seed) {\n      throw new Error(\"seed is required.\");\n    }\n    let wallet = await UniversalWallet2020.generate(_seed);\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n  toggleLockStatus: ({ setUniversalWalletProp }) => async ({\n    status,\n    password,\n    contents,\n  }) => {\n    let wallet = new UniversalWallet2020(contents);\n    wallet.status = status;\n\n    if (status === \"LOCKED\") {\n      await wallet.unlock(password);\n    }\n    if (status === \"UNLOCKED\") {\n      await wallet.lock(password);\n    }\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n\n  deleteWallet: ({ setUniversalWalletProp }) => async () => {\n    setUniversalWalletProp({\n      status: \"UNLOCKED\",\n      contents: [],\n    });\n  },\n\n  importWallet: ({ setUniversalWalletProp }) => async (encryptedWallet) => {\n    let wallet = new UniversalWallet2020();\n    await wallet.import(encryptedWallet);\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n\n  exportWallet: () => async (status, contents) => {\n    if (status !== \"LOCKED\") {\n      throw new Error(\"Cannot export unlocked wallet.\");\n    }\n    let wallet = new UniversalWallet2020(contents);\n    wallet.status = status;\n    return wallet.export();\n  },\n\n  saveWallet: ({ setUniversalWalletProp }) => async (contents) => {\n    setUniversalWalletProp({\n      contents,\n    });\n  },\n  issueCredential: ({ wallet, setUniversalWalletProp }) => async ({\n    credential,\n    options,\n  }) => {\n    let _wallet = new UniversalWallet2020(wallet.contents);\n    const verifiableCredential = await _wallet.issue({\n      credential,\n      options,\n    });\n    setUniversalWalletProp({\n      contents: [verifiableCredential, ..._wallet.contents],\n    });\n  },\n  proveVerifiableCredential: ({ wallet, setUniversalWalletProp }) => async ({\n    verifiableCredential,\n    options,\n  }) => {\n    let _wallet = new UniversalWallet2020(wallet.contents);\n    const verifiablePresentation = await _wallet.prove({\n      verifiableCredential,\n      options,\n    });\n    setUniversalWalletProp({\n      contents: [verifiablePresentation, ..._wallet.contents],\n    });\n  },\n  syncVault: ({ wallet, setUniversalWalletProp }) => async () => {\n    setUniversalWalletProp({\n      isSyncing: true,\n    });\n    const client = await getClient(wallet);\n\n    let contents = [];\n    try {\n      contents = await client.getWalletContents();\n    } catch (e) {\n      console.log(e);\n      if (e.message === \"Request failed with status code 404\") {\n        // no-op we will add content that does not existt anyway..\n      }\n    }\n    // console.log('remote wallet contents: ', contents);\n\n    for (const content of wallet.contents) {\n      // console.log({ content });\n      const isPersisted = isContentPersisted(contents, content.id);\n      // console.log({ isPersisted });\n      if (!isPersisted) {\n        let data = JSON.parse(JSON.stringify(content));\n        delete data.tableData;\n        const doc = {\n          id: await EdvClient.generateId(),\n          content: {\n            schema: \"https://schema.org/UniversalWallet\",\n            data,\n          },\n        };\n        await client.addWalletContent(doc);\n        // console.log({ response });\n      }\n    }\n\n    contents = await client.getWalletContents();\n    setUniversalWalletProp({\n      isSyncing: false,\n      contents,\n    });\n  },\n});\n","module.exports = __webpack_public_path__ + \"static/media/logo.33b194d8.svg\";","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport Base from \"../base/base\";\nimport { openDB } from 'idb';\nimport {KeyPair, createDetachedJws} from '@transmute/did-key-web-crypto'\n\nimport * as vcjs from \"@transmute/vc.js\";\n\nimport {\n  JsonWebKey,\n  JsonWebSignature,\n} from \"@transmute/json-web-signature-2020\";\nimport Room from 'ipfs-pubsub-room'\n\n\nimport credential from './credential.json'\nimport {documentLoader} from './documentLoader'\nimport { Typography } from \"@material-ui/core\";\nimport {getLibp2p} from './libp2p';\n\nconst dbPromise = openDB('keyval-store', 1, {\n  upgrade(db) {\n    db.createObjectStore('keyval');\n  },\n});\n\nconst idbKeyval = {\n  async get(key) {\n    return (await dbPromise).get('keyval', key);\n  },\n  async set(key, val) {\n    return (await dbPromise).put('keyval', val, key);\n  },\n  async delete(key) {\n    return (await dbPromise).delete('keyval', key);\n  },\n  async clear() {\n    return (await dbPromise).clear('keyval');\n  },\n  async keys() {\n    return (await dbPromise).getAllKeys('keyval');\n  },\n};\n\nlet peerCredentials = {};\nwindow.peerCredentials = peerCredentials;\n\nexport const Unextractable = () => {\n\n  const [yourNode, setYourNode] = React.useState({\n  })\n\n  const [observedCredentials, setObservedCredentials] = React.useState({\n  })\n\n  React.useEffect(()=>{\n    (async ()=>{\n      let usableKey  = await idbKeyval.get('myKey')\n\n      if (usableKey === undefined){\n        const algorithm = { name: 'ECDSA', namedCurve: 'P-256'}\n        const extractable = false;\n        // const keyUsages = ['encrypt', 'decrypt', 'sign', 'verify', 'deriveKey', 'deriveBits', 'deriveBits', 'wrapKey', 'unwrapKey'];\n        const keyUsages = ['sign', 'verify'];\n        const result = await crypto.subtle.generateKey(algorithm, extractable, keyUsages);\n        try{\n          await crypto.subtle.exportKey('jwk', result.privateKey)\n        } catch(e){\n          console.info('Expected Unextractable: ', e.message);\n        }\n        usableKey  = await idbKeyval.set('myKey', result)\n      } else {\n        // console.log(usableKey)\n        // now we have a key to use...\n      }\n\n      const publicKeyJwk =  await crypto.subtle.exportKey('jwk', usableKey.publicKey)\n      const keyJson = (await KeyPair.from({publicKeyJwk})).toJsonWebKeyPair(false)\n      keyJson.id = keyJson.controller + keyJson.id;\n      const keypair = await JsonWebKey.from(keyJson)\n      \n      keypair.signer = ()=> {\n        return {\n          sign: async ({data}) => {\n           \n            return createDetachedJws({\n              sign: async (data) => {\n                const signature = await crypto.subtle.sign(\n                  {\n                    name: 'ECDSA',\n                    hash: { name: 'SHA-256' },\n                  },\n                  usableKey.privateKey,\n                  data\n                );\n                return signature;\n              },\n            }, data, { alg: 'ES256', b64: false, crit: ['b64'] });\n          },\n        }\n      };\n\n      if (window.location.hash === ''){\n        window.location = '#' + keypair.controller;\n      }\n\n      const {libp2p} = await getLibp2p();\n\n      const peerId = libp2p.peerId.toB58String();\n\n       const suite = new JsonWebSignature({\n        key: keypair,\n        date: credential.issuanceDate,\n      });\n\n      const verifiableCredential = await vcjs.ld.issue({\n        credential: {\n          ...credential,\n          issuer: {\n            ...credential.issuer,\n            id: keypair.controller,\n          },\n          credentialSubject: {\n            ...credential.credentialSubject,\n            id: peerId\n          }\n        },\n        suite,\n        documentLoader: async (uri) => {\n          const res = await documentLoader(uri);\n          // uncomment to debug\n          // console.log(res);\n          return res;\n        },\n      });\n\n      setYourNode(verifiableCredential)\n     \n\n      const room = new Room(libp2p, 'https://did.key.transmute.industries')\n\n      setInterval(()=>{\n        room.broadcast(Buffer.from(JSON.stringify({type: 'peerIdAssertion', verifiableCredential})))\n      }, 10 * 1000)\n\n      room.on('peer joined', (peer) => {\n        console.log('Peer joined the room', peer)\n      })\n      \n      room.on('peer left', (peer) => {\n        console.log('Peer left...', peer)\n      })\n      \n      // now started to listen to room\n      room.on('subscribed', () => {\n        console.log('Now connected!')\n      })\n\n      room.on('message', async (message) => {\n        const messageJson = JSON.parse(Buffer.from(message.data).toString());\n        if (messageJson.type === 'peerIdAssertion'){\n          const result = await vcjs.ld.verifyCredential({\n            credential: { ...messageJson.verifiableCredential },\n            suite: new JsonWebSignature(),\n            documentLoader: async (uri) => {\n              const res = await documentLoader(uri);\n              // uncomment to debug\n              // console.log(res);\n              return res;\n            },\n          });\n     \n          if (result.verified){\n            console.log(`\\n\\nVerified Peer ${JSON.stringify(messageJson.verifiableCredential, null, 2)}`);\n            setObservedCredentials( (observedCredentials) => {\n              return {...observedCredentials,\n                [messageJson.verifiableCredential.credentialSubject.id]: messageJson.verifiableCredential}\n            })\n          } else {\n            console.error(result)\n          }\n        }\n      })     \n    })()\n  }, [])\n  return (\n    <Base>\n    <Typography>\n      WebRTC Demo of Verifiable Credentials and Unextractable Web Crypto DID Key.\n    </Typography>\n\n    <Typography variant={'h6'}>\n      Your Are:\n    </Typography>\n      <pre>{JSON.stringify(yourNode, null, 2 )}</pre>\n    <Typography variant={'h6'}>\n      Your Peers:\n    </Typography>\n    <pre>{JSON.stringify(observedCredentials, null, 2 )}</pre>\n    </Base>\n  );\n};\n\nUnextractable.propTypes = {};\n","// Pulled from https://github.com/mattrglobal/bls12381-key-pair\n// License is Apache-2.0\n\n/**\n * z represents the multibase encoding scheme of base58 encoding\n * @see https://github.com/multiformats/multibase/blob/master/multibase.csv#L18\n * @ignore\n */\nconst MULTIBASE_ENCODED_BASE58_IDENTIFIER = \"z\";\n\n/**\n * 0x01 indicates the end of the leading bytes according to variable integer spec\n * @see https://github.com/multiformats/multicodec\n * @ignore\n */\nconst VARIABLE_INTEGER_TRAILING_BYTE = 0x01;\n\n\n/**\n * 0xea indicates a BLS 12-381 G1 public key\n *\n */\nconst BLS12381G1_MULTICODEC_IDENTIFIER = 0xea;\n\n\n/**\n * 0xeb indicates a BLS 12-381 G2 public key\n *\n */\nconst BLS12381G2_MULTICODEC_IDENTIFIER = 0xeb;\n\n\n/**\n * 0xee indicates a BLS 12-381 G1 concat with BLS 12-381 G2\n *\n */\nconst BLS12381G1ANDG2_MULTICODEC_IDENTIFIER = 0xee;\n\n\nexport {\n    MULTIBASE_ENCODED_BASE58_IDENTIFIER,\n    VARIABLE_INTEGER_TRAILING_BYTE,\n    BLS12381G1_MULTICODEC_IDENTIFIER,\n    BLS12381G2_MULTICODEC_IDENTIFIER,\n    BLS12381G1ANDG2_MULTICODEC_IDENTIFIER\n}","import { Crypto } from '@peculiar/webcrypto';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined' &&\n    typeof window !== undefined\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto as Crypto;\n}\n\nexport default crypto;\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-common';\n\nexport const jwkToBase58 = (jwk: any): types.LinkedDataKeyPair => {\n  let keypair: any = {};\n  if (jwk.d) {\n    keypair.privateKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.d)])\n    );\n  }\n  if (jwk.x) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x)])\n    );\n  }\n  if (jwk.x && jwk.y) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x), base64url.toBuffer(jwk.y)])\n    );\n  }\n\n  return keypair;\n};\n","export const fingerprintToDid = (fingerprint: string, methodName = 'key') => {\n  return `did:${methodName}:${fingerprint}`;\n};\n","import { types } from '@transmute/did-key-common';\n\nimport { jwkToBase58 } from './jwkToBase58';\nimport { getMultibaseFromJwk } from './getMultibaseFromJwk';\nimport { fingerprintToDid } from './fingerprintToDid';\n\nexport const fromJwk = (jwk: any): types.LinkedDataKeyPair => {\n  const id = getMultibaseFromJwk(jwk);\n  const controller = fingerprintToDid(id);\n  return {\n    id: `#${id}`,\n    type: 'JsonWebKey2020',\n    controller,\n    ...(jwkToBase58(jwk) as any),\n  };\n};\n","import bs58 from 'bs58';\n\nimport { crvToMulticodecPrefix } from '../constants';\nimport { jwkToBase58 } from './jwkToBase58';\n\nexport const getMultibaseFromJwk = (publicKeyJwk: any): string => {\n  const { publicKeyBase58 } = jwkToBase58(publicKeyJwk);\n  const publicKeyBytes = bs58.decode(publicKeyBase58);\n  const prefix = crvToMulticodecPrefix[publicKeyJwk.crv];\n  const buffer = new Uint8Array(3 + publicKeyBytes.length);\n  // https://github.com/multiformats/multicodec/pull/190\n  buffer[0] = 0x12;\n  buffer[1] = prefix;\n  buffer[2] = 0x01;\n  buffer.set(publicKeyBytes, 3);\n  // prefix with `z` to indicate multi-base base58btc encoding\n  return `z${bs58.encode(buffer)}`;\n};\n","import crypto from '../crypto';\nimport { Jws } from '@transmute/did-key-common';\n\nimport { crvToJwsHashAlg } from '../constants';\n\nconst { createJws, verifyJws, createDetachedJws, verifyDetachedJws } = Jws;\n\nexport { createJws, verifyJws, createDetachedJws, verifyDetachedJws };\n\nexport const privateKeyToSigner = async (privateKeyJwk: any) => {\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['sign']\n  );\n\n  return {\n    sign: async (data: Buffer) => {\n      const signature = await crypto.subtle.sign(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[privateKeyJwk.crv] },\n        },\n        privateKey,\n        data\n      );\n      return signature as Buffer;\n    },\n  };\n};\n\nexport const publicKeyToVerifier = async (publicKeyJwk: any) => {\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['verify']\n  );\n\n  return {\n    verify: async (toBeVerified: Buffer, signature: Buffer) => {\n      const verified = await crypto.subtle.verify(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[publicKeyJwk.crv] },\n        },\n        publicKey,\n        signature,\n        toBeVerified\n      );\n      return verified;\n    },\n  };\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-common';\n\nexport const base58KeyPairToJwk = (\n  keypair: types.LinkedDataKeyPair\n): object => {\n  const publicKeyBuffer = bs58.decode(keypair.publicKeyBase58);\n\n  const x = base64url.encode(\n    publicKeyBuffer.slice(0, publicKeyBuffer.length / 2)\n  );\n\n  const y = base64url.encode(publicKeyBuffer.slice(publicKeyBuffer.length / 2));\n\n  let jwk: any = { x, y };\n\n  if (keypair.privateKeyBase58) {\n    jwk.d = base64url.encode(bs58.decode(keypair.privateKeyBase58));\n  }\n\n  return jwk;\n};\n","import bs58 from 'bs58';\nimport { multicodecToJwkType } from '../constants';\nexport const getJwkTypeFromMultibase = (fingerprint: string) => {\n  const buffer = bs58.decode(fingerprint.substring(1));\n\n  if (buffer[0] !== 0x12) {\n    throw new Error(`Unsupported multibase ${buffer[0].toString(16)}`);\n  }\n\n  const type = multicodecToJwkType[buffer[1]];\n  if (!type) {\n    throw new Error(\n      `Unsupported multibase ${buffer[0].toString(16)} ${buffer[1].toString(\n        16\n      )}`\n    );\n  }\n  return type;\n};\n","import { types } from '@transmute/did-key-common';\n\nimport { base58KeyPairToJwk } from './base58KeyPairToJwk';\nimport { getJwkTypeFromMultibase } from './getJwkTypeFromMultibase';\nexport const toJwkPair = (\n  keypair: types.LinkedDataKeyPair\n): types.JsonWebKeyPair => {\n  // console.log('toJwkPair', keypair);\n  const id = keypair.id.substring(keypair.id.indexOf('#') + 1);\n  let _keypair: any = {\n    id: keypair.id,\n    type: 'JsonWebKey2020',\n    controller: keypair.controller,\n  };\n\n  _keypair.publicKeyJwk = {\n    ...getJwkTypeFromMultibase(id),\n    ...base58KeyPairToJwk({\n      publicKeyBase58: keypair.publicKeyBase58,\n    } as any),\n  };\n\n  if (keypair.privateKeyBase58) {\n    _keypair.privateKeyJwk = {\n      ...getJwkTypeFromMultibase(id),\n      ...base58KeyPairToJwk({\n        publicKeyBase58: keypair.publicKeyBase58,\n        privateKeyBase58: keypair.privateKeyBase58,\n      } as any),\n    };\n  }\n\n  return _keypair;\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { generate } from './functions/generate';\nimport { fromJwk } from './functions/fromJwk';\n\nimport { deriveSecret } from './Jwe';\nimport { privateKeyToSigner, publicKeyToVerifier } from './Jws';\nimport { toJwkPair } from './functions/toJwkPair';\nimport { fingerprintToDid } from './functions/fingerprintToDid';\nimport { getJwkTypeFromMultibase } from './functions/getJwkTypeFromMultibase';\n\nimport { types } from '@transmute/did-key-common';\n\nimport {\n  getEpkGenerator,\n  deriveKey,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\n/* class decorator */\nfunction staticImplements<T>() {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n}\n\nconst KEY_TYPE = 'JsonWebKey2020';\n\n@staticImplements<types.KeyAgreementKeyPairClass>()\nexport class KeyPair implements types.KeyAgreementKeyPairInstance {\n  public static JWE_ALG: types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static generate = async (options?: any) => {\n    const { privateKeyJwk } = await generate(options);\n    return new KeyPair({ ...fromJwk(privateKeyJwk) });\n  };\n\n  static from = (options?: any) => {\n    return new KeyPair({ ...options });\n  };\n\n  static fromFingerprint = async ({ fingerprint }: any) => {\n    const data = getJwkTypeFromMultibase(fingerprint);\n    if (data.kty) {\n      const publicKeyBytes = bs58.decode(fingerprint.substring(1));\n\n      const publicKeyBase58 = bs58.encode(publicKeyBytes.slice(3));\n\n      return new KeyPair({\n        id: '#' + fingerprint,\n        controller: fingerprintToDid(fingerprint),\n        type: 'JsonWebKey2020',\n        publicKeyBase58,\n      });\n    }\n    throw new Error('Cannot create key from fingerprint ' + fingerprint);\n  };\n\n  static fingerprintFromPublicKey(\n    keypair: types.KeyPairJwk | types.KeyPairBase58\n  ) {\n    let kp = KeyPair.from(keypair);\n    return kp.id.substring(1);\n  }\n\n  static async generateEphemeralKeyPair(\n    epkArgs: any\n  ): Promise<types.EpkResult> {\n    return getEpkGenerator(KeyPair, epkArgs)();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = new KeyPair({\n      publicKeyJwk: epk,\n    } as any);\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = ephemeralPublicKey.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey.toJsonWebKeyPair(),\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    if (staticPublicKey.type !== KEY_TYPE) {\n      throw new Error(`\"staticPublicKey.type\" must be \"${KEY_TYPE}\".`);\n    }\n\n    const epkPair = await KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  public id: string;\n  public type: string;\n  public controller: string;\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  constructor(options: any) {\n    this.id = options.id;\n    this.type = options.type || 'JsonWebKey2020';\n\n    this.controller = options.controller;\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      const args = fromJwk(options.publicKeyJwk);\n      this.publicKeyBuffer = bs58.decode(args.publicKeyBase58);\n      this.id = options.id || args.id;\n      this.controller = args.controller;\n    } else {\n      throw new Error('publicKeyJwk or publicKeyBase58 is required.');\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    } else if (options.privateKeyJwk) {\n      const { privateKeyBase58 } = fromJwk(options.privateKeyJwk);\n      this.privateKeyBuffer = bs58.decode(privateKeyBase58);\n    }\n  }\n\n  fingerprint() {\n    const { id } = this.toJsonWebKeyPair();\n    return id.substring(1);\n  }\n\n  toKeyPair(exportPrivateKey = false) {\n    let options: any = {\n      id: this.id,\n      type: 'UnsupportedVerificationMethod2020',\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivateKey) {\n      options.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return options;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey = false) {\n    const options = this.toKeyPair(exportPrivateKey);\n    return toJwkPair(options);\n  }\n\n  async signer() {\n    const { privateKeyJwk } = this.toJsonWebKeyPair(true);\n    return privateKeyToSigner(privateKeyJwk);\n  }\n\n  async verifier() {\n    const { publicKeyJwk } = this.toJsonWebKeyPair();\n    return publicKeyToVerifier(publicKeyJwk);\n  }\n\n  deriveSecret(options: types.DeriveSecretOptions) {\n    const { privateKeyJwk } = this.toJsonWebKeyPair(true);\n    let publicKeyJwk;\n\n    if ((options.publicKey as any).publicKeyJwk) {\n      publicKeyJwk = (options.publicKey as any).publicKeyJwk;\n    } else if ((options.publicKey as any).publicKeyBase58) {\n      ({ publicKeyJwk } = toJwkPair(options.publicKey as any));\n    } else {\n      throw new Error(\n        'Cannot deriveSecret from remote... publicKeyJwk or publicKeyBase58 must be present.'\n      );\n    }\n    return deriveSecret(privateKeyJwk, publicKeyJwk);\n  }\n}\n","import crypto from '../crypto';\n\nexport const deriveSecret = async (\n  privateKeyJwk: any,\n  publicKeyJwk: any\n): Promise<Uint8Array> => {\n  // console.log(privateKeyJwk, publicKeyJwk);\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const result = await crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKey,\n    },\n    privateKey,\n    256\n  );\n  return new Uint8Array(result);\n};\n","import { SUPPORTED_EC } from '../constants';\nimport crypto from '../crypto';\n\nexport interface GenerateOptions {\n  kty: string;\n  crvOrSize: string;\n}\n\nexport const generate = async (\n  options: GenerateOptions = { kty: 'EC', crvOrSize: 'P-256' }\n) => {\n  if (options.kty === 'EC' && SUPPORTED_EC.indexOf(options.crvOrSize) !== -1) {\n    let kp = await crypto.subtle.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: options.crvOrSize,\n      },\n      true,\n      ['sign', 'verify']\n    );\n    const jwk = await crypto.subtle.exportKey('jwk', kp.privateKey);\n    return {\n      publicKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n      },\n      privateKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n        d: jwk.d,\n      },\n    };\n  }\n\n  throw new Error(\n    `Generate does not support ${options.kty} and ${options.crvOrSize}`\n  );\n};\n","import { Secp256k1KeyPair } from './Secp256k1KeyPair';\nimport { getResolve, getGet } from '@transmute/did-key-common';\n\nexport const resolve = getResolve(Secp256k1KeyPair);\nexport const get = getGet(resolve);\n","import Libp2p from 'libp2p'\nimport Websockets from 'libp2p-websockets'\nimport WebRTCStar from 'libp2p-webrtc-star'\nimport { NOISE } from 'libp2p-noise'\nimport Mplex from 'libp2p-mplex'\nimport Bootstrap from 'libp2p-bootstrap'\nimport Gossipsub from 'libp2p-gossipsub'\n\nexport const getLibp2p = async ()=>{\n\n    const libp2p = await Libp2p.create({\n        addresses: {\n          listen: [\n            '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',\n            // '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star'\n          ]\n        },\n        modules: {\n          transport: [Websockets, WebRTCStar],\n          connEncryption: [NOISE],\n          streamMuxer: [Mplex],\n          peerDiscovery: [Bootstrap],\n          pubsub: Gossipsub\n        },\n        config: {\n          peerDiscovery: {\n           [Bootstrap.tag]: {\n              enabled: true,\n              list: [\n                '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',\n                '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n                '/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp',\n                '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n                '/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt'\n              ]\n            }\n          }\n        }\n      })\n  \n  await libp2p.start()\n\n  window.libp2p = libp2p\n  return {libp2p}\n}","/* class decorator */\nexport const staticImplements = <T>() => {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n};\n\nexport * from './JWE_ALG';\nexport * from './JWS_ALG';\n\nexport * from './KeyPairClass';\nexport * from './KeyPairInstance';\nexport * from './KeyAgreementKeyPairClass';\nexport * from './KeyPairGenerateOptions';\nexport * from './EpkResult';\nexport * from './KeyEncryptionKeyFromEphemeralPublicKeyOptions';\nexport * from './KeyEncryptionKeyFromStaticPublicKeyOptions';\nexport * from './DeriveSecretOptions';\n\nexport * from './KeyPairBase';\n\nexport * from './KeyPairJwk';\nexport * from './JsonWebKeyPair';\n\nexport * from './KeyPairBase58';\nexport * from './LinkedDataKeyPair';\n\nexport * from './KeyAgreementKeyPairInstance';\n","import base64url from 'base64url';\nimport canonicalize from 'canonicalize';\n\nexport const createJws = async (signer: any, payload: any, header: object) => {\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  return `${toBeSigned}.${base64url.encode(Buffer.from(signature))}`;\n};\n\nexport const verifyJws = async (verifier: any, jws: string) => {\n  const [header, payload, signature] = jws.split('.');\n  const toBeVerified = `${header}.${payload}`;\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(signature)\n  );\n\n  return verified;\n};\n\nexport const createDetachedJws = async (\n  signer: any,\n  payload: Buffer,\n  header: object\n) => {\n  const encodedHeader = base64url.encode(\n    canonicalize({ ...header, b64: false, crit: ['b64'] })\n  );\n\n  const toBeSigned = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\nexport const verifyDetachedJws = async (\n  verifier: any,\n  payload: Buffer,\n  signature: string\n) => {\n  const [encodedHeader, encodedSignature] = signature.split('..');\n\n  const toBeVerified = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(encodedSignature)\n  );\n\n  return verified;\n};\n","export const getVerificationMethod = (\n  didKeyPairInstance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  let externalKeyRepresentation;\n  switch (contentType) {\n    case 'application/did+json': {\n      externalKeyRepresentation = didKeyPairInstance.toJsonWebKeyPair();\n      break;\n    }\n    case '*/*':\n    case 'application/did+ld+json': {\n      externalKeyRepresentation = didKeyPairInstance.toKeyPair();\n      break;\n    }\n    default: {\n      throw new Error(\n        'This implementation of did:key does not support: ' + contentType\n      );\n    }\n  }\n  return externalKeyRepresentation;\n};\n\nexport const keyToDidDoc = async (\n  didKeyPairInstance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  const did = `did:key:${didKeyPairInstance.fingerprint()}`;\n  const externalKeyRepresentation = getVerificationMethod(\n    didKeyPairInstance,\n    contentType\n  );\n  let verificationRelationships: any = {\n    verificationMethod: [externalKeyRepresentation],\n  };\n\n  if (didKeyPairInstance.verifier) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      authentication: [externalKeyRepresentation.id],\n      assertionMethod: [externalKeyRepresentation.id],\n      capabilityInvocation: [externalKeyRepresentation.id],\n      capabilityDelegation: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.deriveSecret) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      keyAgreement: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.type === 'Ed25519VerificationKey2018') {\n    const kek = await didKeyPairInstance.toX25519KeyPair(false);\n    const externalKeyRepresentation2 = getVerificationMethod(kek, contentType);\n    verificationRelationships = {\n      ...verificationRelationships,\n      verificationMethod: [\n        ...verificationRelationships.verificationMethod,\n        externalKeyRepresentation2,\n      ],\n      keyAgreement: [externalKeyRepresentation2.id],\n    };\n  }\n\n  // imagine if people injected ads like this....\n  // verificationRelationships = {\n  //   ...verificationRelationships,\n  //   service: [\n  //     {\n  //       id: '#provider',\n  //       type: 'ServiceProvider',\n  //       serviceEndpoint: 'https://transmute.industries',\n  //     },\n  //   ],\n  // };\n\n  const didDocument = {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {\n        '@base': did,\n      },\n    ],\n    id: did,\n    ...verificationRelationships,\n  };\n\n  // Here is were I would delete a property for JSON-only\n  // If I wanted to conform to the DID Core JSON Production Rules.\n  return didDocument;\n};\n\n// resolve ( did, did-resolution-input-metadata )\n//      -> ( did-resolution-metadata, did-document, did-document-metadata )\nexport const getResolve = (DidKeyPairClass: any) => {\n  const resolve = async (\n    didUri: string,\n    resolutionMetaData: any = { accept: 'application/did+ld+json' }\n  ) => {\n    const fingerprint = didUri\n      .split('#')[0]\n      .split('did:key:')\n      .pop();\n    const publicKey = await DidKeyPairClass.fromFingerprint({ fingerprint });\n    return {\n      didDocument: await keyToDidDoc(publicKey, resolutionMetaData.accept),\n      didDocumentMetaData: {\n        'content-type': resolutionMetaData.accept,\n      },\n      didResolutionMetaData: {},\n    };\n  };\n  return resolve;\n};\n","export const getGet = (resolve: any) => {\n  const get = async ({ did, url }: any = {}) => {\n    did = did || url;\n    if (!did) {\n      throw new TypeError('\"did\" must be a string.');\n    }\n    const result = await resolve(did);\n    return result.didDocument;\n  };\n  return get;\n};\n","export enum BlsCurveName {\n    G1 = \"BLS12381_G1\",\n    G2 = \"BLS12381_G2\"\n}","import bs58 from 'bs58';\nimport { generateBls12381G1KeyPair , generateBls12381G2KeyPair} from '@mattrglobal/bbs-signatures';\n\nexport const generateKeyPairs = async () =>{\n  \n    const g1 = await generateBls12381G1KeyPair();\n    const g2 = await generateBls12381G2KeyPair();\n\n    const bls12381G1KeyPair = {\n        id: \"\",\n        type: \"Bls12381G1Key2020\",\n        controller: \"\",\n        publicKeyBase58: bs58.encode(g1.publicKey),\n        privateKeyBase58: bs58.encode(g1.secretKey),\n    }\n\n    const bls12381G2KeyPair = {\n        id: \"\",\n        type: \"Bls12381G2Key2020\",\n        controller: \"\",\n        publicKeyBase58: bs58.encode(g2.publicKey),\n        privateKeyBase58: bs58.encode(g2.secretKey),\n    }\n    return {\n        bls12381G1KeyPair, bls12381G2KeyPair\n    }\n}","\nimport bs58 from 'bs58'\nimport base64url from 'base64url'\nimport { MULTIBASE_ENCODED_BASE58_IDENTIFIER, BLS12381G1ANDG2_MULTICODEC_IDENTIFIER, VARIABLE_INTEGER_TRAILING_BYTE } from '../constants'\n\n\nexport const keypairsToDidKey = (g1JsonWebKeyPair:any, g2JsonWebKeyPair:any) =>{\n\n    const g1Buffer = base64url.toBuffer(g1JsonWebKeyPair.publicKeyJwk.x);\n    const g2Buffer = base64url.toBuffer(g2JsonWebKeyPair.publicKeyJwk.x);\n    const g1AndG2 = Buffer.concat([g1Buffer, g2Buffer]);\n    const buffer = new Uint8Array(2 + g1AndG2.length);\n    buffer[0] = BLS12381G1ANDG2_MULTICODEC_IDENTIFIER;\n    buffer[1] = VARIABLE_INTEGER_TRAILING_BYTE;\n\n    buffer.set(g1AndG2, 2);\n    return `did:key:${MULTIBASE_ENCODED_BASE58_IDENTIFIER}${bs58.encode(buffer)}`\n}","import { BlsCurveName } from '../types'\nimport base64url from 'base64url'\nimport bs58 from 'bs58'\nconst curveMap:any = {\n    'Bls12381G1Key2020': BlsCurveName.G1,\n    'Bls12381G2Key2020': BlsCurveName.G2\n}\n\nexport const toJsonWebKeyPair = (keypair: any)=>{\n\n    const jsonWebKeyPair:any = {\n        id: keypair.id,\n        controller: keypair.controller,\n        type:'JsonWebKey2020',\n        publicKeyJwk: {\n            \"kty\": \"EC\",\n            \"crv\": curveMap[keypair.type],\n            \"x\": base64url.encode(bs58.decode(keypair.publicKeyBase58))\n        }\n    }\n\n    if (keypair.privateKeyBase58){\n        jsonWebKeyPair.privateKeyJwk = {\n            \"kty\": \"EC\",\n            \"crv\": curveMap[keypair.type],\n            \"x\": base64url.encode(bs58.decode(keypair.publicKeyBase58)),\n            \"d\": base64url.encode(bs58.decode(keypair.privateKeyBase58)),\n        }\n    }\n   \n    return jsonWebKeyPair;\n}","import bs58 from 'bs58'\n\nimport {BLS12381G1ANDG2_MULTICODEC_IDENTIFIER, BLS12381G1_MULTICODEC_IDENTIFIER, BLS12381G2_MULTICODEC_IDENTIFIER, VARIABLE_INTEGER_TRAILING_BYTE} from '../constants'\n\nimport {toJsonWebKeyPair}from './toJsonWebKeyPair'\nexport const fingerprintToJsonWebKeyPair = (fingerprint: string)=>{\n\n    if (fingerprint[0]!== 'z'){\n        throw new Error('base58 encoded fingerprint must start with \"z\"')\n    }\n\n    const buffer = bs58.decode(fingerprint.substring(1))\n\n    if (buffer[0] === BLS12381G1_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {\n        let kp = toJsonWebKeyPair({\n            type:'Bls12381G1Key2020',\n            publicKeyBase58: bs58.encode(buffer.slice(2))\n        })\n        return {\n            bls12381G1KeyPair: {\n                ...kp,\n                id: '#' + fingerprint,\n                controller: `did:key:${fingerprint}`\n            }\n        }\n    }\n\n    if (buffer[0] === BLS12381G2_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {\n        let kp = toJsonWebKeyPair({\n            type:'Bls12381G2Key2020',\n            publicKeyBase58: bs58.encode(buffer.slice(2))\n        })\n        return {\n            bls12381G2KeyPair: {\n                ...kp,\n                id: '#' + fingerprint,\n                controller: `did:key:${fingerprint}`\n            }\n        }\n    }\n\n    if (buffer[0] === BLS12381G1ANDG2_MULTICODEC_IDENTIFIER && buffer[1] === VARIABLE_INTEGER_TRAILING_BYTE) {\n\n        let g1 = toJsonWebKeyPair({\n            type:'Bls12381G1Key2020',\n            publicKeyBase58: bs58.encode(buffer.slice(2), 50)\n        })\n\n        let g2 = toJsonWebKeyPair({\n            type:'Bls12381G2Key2020',\n            publicKeyBase58: bs58.encode(buffer.slice(50))\n        })\n        return {\n            bls12381G1KeyPair: {\n                ...g1,\n                id: '#' + fingerprint,\n                controller: `did:key:${fingerprint}`\n            },\n            bls12381G2KeyPair: {\n                ...g2,\n                id: '#' + fingerprint,\n                controller: `did:key:${fingerprint}`\n            }\n        }\n    }\n\n    throw new Error('unsupported fingerprint is not g1, g2 or g1 and g2.')\n}","import bs58 from 'bs58'\nimport base64url from 'base64url'\nimport { MULTIBASE_ENCODED_BASE58_IDENTIFIER, BLS12381G1_MULTICODEC_IDENTIFIER, BLS12381G2_MULTICODEC_IDENTIFIER, VARIABLE_INTEGER_TRAILING_BYTE } from '../constants'\nimport { BlsCurveName } from '../types'\n\nconst curveToMulticodecMap: any = {\n    [BlsCurveName.G1]: BLS12381G1_MULTICODEC_IDENTIFIER,\n    [BlsCurveName.G2]: BLS12381G2_MULTICODEC_IDENTIFIER,\n}\n\nexport const publicKeyJwkToDidKey = (publicKeyJwk:any)=>{\n\n    const publicKey = base64url.toBuffer(publicKeyJwk.x);\n    \n    const buffer = new Uint8Array(2 + publicKey.length);\n    buffer[0] = curveToMulticodecMap[publicKeyJwk.crv];\n    buffer[1] = VARIABLE_INTEGER_TRAILING_BYTE;\n\n    buffer.set(publicKey, 2);\n\n    return `did:key:${MULTIBASE_ENCODED_BASE58_IDENTIFIER}${bs58.encode(buffer)}`\n}","\nimport bs58 from 'bs58'\nimport base64url from 'base64url'\nimport * as mattr from '@mattrglobal/bls12381-key-pair'\nimport {generateKeyPairs} from './functions/generateKeyPairs';\nimport {toJsonWebKeyPair} from './functions/toJsonWebKeyPair';\nimport {publicKeyJwkToDidKey} from './functions/publicKeyJwkToDidKey';\nimport {fingerprintToJsonWebKeyPair} from './functions/fingerprintToJsonWebKeyPair'\n\nexport class Bls12381G1KeyPair {\n  public id: string;\n  public type: string = 'Bls12381G1Key2020';\n  public controller: string;\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static async generate() {\n    const { bls12381G1KeyPair } = await generateKeyPairs();\n    const {publicKeyJwk} = toJsonWebKeyPair(bls12381G1KeyPair)\n    bls12381G1KeyPair.controller = publicKeyJwkToDidKey(publicKeyJwk)\n    bls12381G1KeyPair.id = '#' + bls12381G1KeyPair.controller.split('did:key:').pop();\n    return new Bls12381G1KeyPair({\n      id: bls12381G1KeyPair.id,\n      controller: bls12381G1KeyPair.controller,\n      publicKeyBuffer: bs58.decode(bls12381G1KeyPair.publicKeyBase58),\n      privateKeyBuffer: bs58.decode(bls12381G1KeyPair.privateKeyBase58)\n    })\n  }\n\n  static async fromFingerprint({ fingerprint }: any) {\n    const {bls12381G1KeyPair} = fingerprintToJsonWebKeyPair(fingerprint)\n    return new Bls12381G1KeyPair({\n      id: bls12381G1KeyPair.id,\n      controller: bls12381G1KeyPair.controller,\n      publicKeyBuffer: base64url.toBuffer(bls12381G1KeyPair.publicKeyJwk.x)\n    });\n  }\n\n  static async from(options: any) {\n\n    if (options.type === 'JsonWebKey2020'){\n      let opts: any = {\n        id: options.id,\n        controller: options.controller,\n        publicKeyBuffer: base64url.toBuffer(options.publicKeyJwk.x)\n      }\n      if (options.privateKeyJwk){\n        opts.privateKeyBuffer = base64url.toBuffer(options.privateKeyJwk.d)\n      }\n      return new Bls12381G1KeyPair(opts);\n    }\n\n    if (options.type === 'Bls12381G1Key2020'){\n      let opts: any = {\n        id: options.id,\n        controller: options.controller,\n        publicKeyBuffer: bs58.decode(options.publicKeyBase58)\n      }\n      if (options.privateKeyBase58){\n        opts.privateKeyBuffer = bs58.decode(options.privateKeyBase58)\n      }\n      return new Bls12381G1KeyPair(opts);\n    }\n\n    throw new Error('unsuported key type')\n    \n  }\n\n  constructor(options: any) {\n    this.id = options.id;\n    this.controller = options.controller;\n    this.publicKeyBuffer = options.publicKeyBuffer;\n    this.privateKeyBuffer = options.privateKeyBuffer;\n    if (!this.controller){\n      const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n      this.controller = publicKeyJwkToDidKey(publicKeyJwk);\n      \n    }\n    if (!this.id){\n      const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n      this.id = '#' + publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop();\n      \n    }\n    \n  }\n\n  fingerprint(){\n    const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n    return publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop()\n  }\n\n  toKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n\n    if (exportPrivateKey) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey = false) {\n    const result = toJsonWebKeyPair(this.toKeyPair(exportPrivateKey))\n    return result\n  }\n\n  verifier() {\n    const key = new mattr.Bls12381G1KeyPair({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    });\n   return key.verifier()\n  }\n\n  signer() {\n    const key = new mattr.Bls12381G1KeyPair({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n      privateKeyBase58: bs58.encode(this.privateKeyBuffer)\n    });\n   return key.signer()\n  }\n}\n","\nimport bs58 from 'bs58'\nimport base64url from 'base64url'\nimport * as mattr from '@mattrglobal/bls12381-key-pair'\nimport {generateKeyPairs} from './functions/generateKeyPairs';\nimport {toJsonWebKeyPair} from './functions/toJsonWebKeyPair';\nimport {publicKeyJwkToDidKey} from './functions/publicKeyJwkToDidKey';\nimport {fingerprintToJsonWebKeyPair} from './functions/fingerprintToJsonWebKeyPair'\n\nexport class Bls12381G2KeyPair {\n  public id: string;\n  public type: string = 'Bls12381G2Key2020';\n  public controller: string;\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static async generate() {\n    const { bls12381G2KeyPair } = await generateKeyPairs();\n    const {publicKeyJwk} = toJsonWebKeyPair(bls12381G2KeyPair)\n    bls12381G2KeyPair.controller = publicKeyJwkToDidKey(publicKeyJwk)\n    bls12381G2KeyPair.id = '#' + bls12381G2KeyPair.controller.split('did:key:').pop();\n    return new Bls12381G2KeyPair({\n      id: bls12381G2KeyPair.id,\n      controller: bls12381G2KeyPair.controller,\n      publicKeyBuffer: bs58.decode(bls12381G2KeyPair.publicKeyBase58),\n      privateKeyBuffer: bs58.decode(bls12381G2KeyPair.privateKeyBase58)\n    })\n  }\n\n  static async fromFingerprint({ fingerprint }: any) {\n    const {bls12381G2KeyPair} = fingerprintToJsonWebKeyPair(fingerprint)\n    return new Bls12381G2KeyPair({\n      id: bls12381G2KeyPair.id,\n      controller: bls12381G2KeyPair.controller,\n      publicKeyBuffer: base64url.toBuffer(bls12381G2KeyPair.publicKeyJwk.x)\n    });\n  }\n\n  static async from(options: any) {\n\n    if (options.type === 'JsonWebKey2020'){\n      let opts: any = {\n        id: options.id,\n        controller: options.controller,\n        publicKeyBuffer: base64url.toBuffer(options.publicKeyJwk.x)\n      }\n      if (options.privateKeyJwk){\n        opts.privateKeyBuffer = base64url.toBuffer(options.privateKeyJwk.d)\n      }\n      return new Bls12381G2KeyPair(opts);\n    }\n\n    if (options.type === 'Bls12381G2Key2020'){\n      let opts: any = {\n        id: options.id,\n        controller: options.controller,\n        publicKeyBuffer: bs58.decode(options.publicKeyBase58)\n      }\n      if (options.privateKeyBase58){\n        opts.privateKeyBuffer = bs58.decode(options.privateKeyBase58)\n      }\n      return new Bls12381G2KeyPair(opts);\n    }\n\n    throw new Error('unsuported key type')\n    \n  }\n\n  constructor(options: any) {\n    this.id = options.id;\n    this.controller = options.controller;\n    this.publicKeyBuffer = options.publicKeyBuffer;\n    this.privateKeyBuffer = options.privateKeyBuffer;\n\n    if (!this.controller){\n      const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n      this.controller = publicKeyJwkToDidKey(publicKeyJwk);\n      \n    }\n    if (!this.id){\n      const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n      this.id = '#' + publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop();\n    }\n    \n  }\n\n  fingerprint(){\n    const { publicKeyJwk } = this.toJsonWebKeyPair(false);\n    return publicKeyJwkToDidKey(publicKeyJwk).split('did:key:').pop()\n  }\n\n  toKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n\n    if (exportPrivateKey) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey = false) {\n    return toJsonWebKeyPair(this.toKeyPair(exportPrivateKey))\n  }\n\n  verifier() {\n    const key = new mattr.Bls12381G2KeyPair({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    });\n   return key.verifier()\n  }\n\n  signer() {\n    const key = new mattr.Bls12381G2KeyPair({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n      privateKeyBase58: bs58.encode(this.privateKeyBuffer)\n    });\n   return key.signer()\n  }\n}\n","\nimport bs58 from 'bs58'\n// import base64url from 'base64url'\n// import * as mattr from '@mattrglobal/bls12381-key-pair'\nimport {generateKeyPairs} from './functions/generateKeyPairs';\nimport {keypairsToDidKey} from './functions/keypairsToDidKey'\nimport {fingerprintToJsonWebKeyPair} from './functions/fingerprintToJsonWebKeyPair'\nimport { Bls12381G1KeyPair } from './Bls12381G1KeyPair'\nimport { Bls12381G2KeyPair } from './Bls12381G2KeyPair'\n\nexport class Bls12381KeyPairs {\n  public id: string;\n  public type: string = 'Bls12381KeyPairs2020'\n  public controller: string;\n  public g1KeyPair: Bls12381G1KeyPair;\n  public g2KeyPair: Bls12381G2KeyPair;\n\n  static async generate() {\n    const { bls12381G1KeyPair, bls12381G2KeyPair } = await generateKeyPairs();\n    const options = {\n      id: \"\",\n      controller: \"\",\n      g1KeyPair: new Bls12381G1KeyPair({\n        id: bls12381G2KeyPair.id,\n        // controller: bls12381G2KeyPair.controller,\n        publicKeyBuffer: bs58.decode(bls12381G1KeyPair.publicKeyBase58),\n        privateKeyBuffer: bs58.decode(bls12381G1KeyPair.privateKeyBase58)\n      }),\n      g2KeyPair: new Bls12381G2KeyPair({\n        id: bls12381G2KeyPair.id,\n        // controller: bls12381G2KeyPair.controller,\n        publicKeyBuffer: bs58.decode(bls12381G2KeyPair.publicKeyBase58),\n        privateKeyBuffer: bs58.decode(bls12381G2KeyPair.privateKeyBase58)\n      })\n    }\n    const did = keypairsToDidKey(options.g1KeyPair.toJsonWebKeyPair(false), options.g2KeyPair.toJsonWebKeyPair(false))\n    options.g1KeyPair.controller = did;\n    options.g2KeyPair.controller = did;\n    options.controller = did;\n    options.id = '#' + did.split('did:key:').pop();\n\n    return new Bls12381KeyPairs(options)\n  }\n\n  static async fromFingerprint({fingerprint}:any){\n    if (fingerprint.indexOf('z5T') === 0){\n      const {bls12381G1KeyPair, bls12381G2KeyPair} = fingerprintToJsonWebKeyPair(fingerprint)\n      delete bls12381G1KeyPair.id;\n      delete bls12381G2KeyPair.id\n      const controller = 'did:key:'+ fingerprint;\n      bls12381G1KeyPair.controller = controller;\n      bls12381G2KeyPair.controller = controller;\n      return new Bls12381KeyPairs({\n        id: '#' + fingerprint,\n        controller,\n        g1KeyPair: await Bls12381G1KeyPair.from(bls12381G1KeyPair),\n        g2KeyPair: await Bls12381G2KeyPair.from(bls12381G2KeyPair)\n      })\n    }\n    if (fingerprint.indexOf('z3t') === 0){\n      return Bls12381G1KeyPair.fromFingerprint({fingerprint})\n    }\n    if (fingerprint.indexOf('zUC') === 0){\n      return Bls12381G2KeyPair.fromFingerprint({fingerprint})\n    }\n    throw new Error('Bls12381KeyPairs only supports g1, g2 and g1 and g2 mulicodec fingerprints.')\n  }\n\n  constructor(options:any){\n    this.id = options.id;\n    this.controller = options.controller;\n    this.g1KeyPair = options.g1KeyPair;\n    this.g2KeyPair = options.g2KeyPair;\n  }\n\n  fingerprint(){\n    const did = keypairsToDidKey(this.g1KeyPair.toJsonWebKeyPair(false), this.g2KeyPair.toJsonWebKeyPair(false))\n    return did.split('did:key:').pop();\n  }\n\n  export(exportPrivate = false){\n    return {\n      fingerprint: this.fingerprint(),\n      g1: this.g1KeyPair.toJsonWebKeyPair(exportPrivate),\n      g2: this.g2KeyPair.toJsonWebKeyPair(exportPrivate)\n    }\n  }\n\n}\n","import {Bls12381KeyPairs } from '../Bls12381KeyPairs'\nexport const getVerificationMethod = (\n    didKeyPairInstance: any,\n    contentType: string = 'application/did+ld+json'\n  ) => {\n    let externalKeyRepresentation;\n    switch (contentType) {\n      case 'application/did+json': {\n        externalKeyRepresentation = didKeyPairInstance.toJsonWebKeyPair();\n        break;\n      }\n      case '*/*':\n      case 'application/did+ld+json': {\n        externalKeyRepresentation = didKeyPairInstance.toKeyPair();\n        break;\n      }\n      default: {\n        throw new Error(\n          'This implementation of did:key does not support: ' + contentType\n        );\n      }\n    }\n    return externalKeyRepresentation;\n  };\n\nexport const keyToDidDoc = async (\n    didKeyPairInstance: any,\n    contentType: string = 'application/did+ld+json'\n  ) => {\n    let verificationRelationships: any = {\n      verificationMethod: [],\n    };\n    const did = `did:key:${didKeyPairInstance.fingerprint()}`;  \n    if (didKeyPairInstance.type === 'Bls12381KeyPairs2020'){\n      const g1 = getVerificationMethod((didKeyPairInstance as Bls12381KeyPairs).g1KeyPair, contentType);\n      const g2 = getVerificationMethod((didKeyPairInstance as Bls12381KeyPairs).g2KeyPair, contentType)\n      verificationRelationships.verificationMethod.push(g1);\n      verificationRelationships.verificationMethod.push(g2);\n      verificationRelationships = {\n        ...verificationRelationships,\n        authentication: [g1.id, g2.id],\n        assertionMethod: [g1.id, g2.id],\n        capabilityInvocation: [g1.id, g2.id],\n        capabilityDelegation: [g1.id, g2.id],\n      };\n    } else {\n      const vm = getVerificationMethod(didKeyPairInstance, contentType);\n      verificationRelationships.verificationMethod.push(vm);\n      verificationRelationships = {\n        ...verificationRelationships,\n        authentication: [vm.id],\n        assertionMethod: [vm.id],\n        capabilityInvocation: [vm.id],\n        capabilityDelegation: [vm.id],\n      };\n    }\n  \n    const didDocument = {\n      '@context': [\n        'https://www.w3.org/ns/did/v1',\n        {\n          '@base': did,\n        },\n      ],\n      id: did,\n      ...verificationRelationships,\n    };\n  \n    return didDocument;\n  };\n  ","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 1597;","import { Crypto } from '@peculiar/webcrypto';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined'\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto;\n}\n\nexport default crypto;\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\n\n// only supported algorithm\nconst KEY_ALGORITHM = 'ECDH-ES+A256KW';\n\n// create static ALGORITHM_ID\nconst ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();\nconst ALGORITHM_ID = new Uint8Array(4 + ALGORITHM_CONTENT.length);\n// write length of content as 32-bit big endian integer, then write content\nconst dv = new DataView(\n  ALGORITHM_ID.buffer,\n  ALGORITHM_ID.byteOffset,\n  ALGORITHM_ID.byteLength\n);\ndv.setUint32(0, ALGORITHM_CONTENT.length);\nALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4);\n\n// RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF\n// https://tools.ietf.org/html/rfc7518#section-4.6.2\nconst HASH_ALGORITHM = { name: 'SHA-256' };\n\n// derived keys are always 256-bits\nconst KEY_LENGTH = 256;\n\n/**\n * Derives a 256-bit AES-KW key encryption key from a shared secret that\n * was derived from an ephemeral and static pair\n * of Elliptic Curve Diffie-Hellman keys.\n *\n * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,\n * which defines how to perform Curve25519 (X25519) ECDH key agreement.\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.\n * @param {Uint8Array} options.producerInfo - An array of application-specific\n *   bytes describing the consumer (aka the \"encrypter\" or \"sender\").\n * @param {Uint8Array} options.consumerInfo - An array of application-specific\n *   bytes describing the producer (aka the \"decrypter\" or\n *   \"receiver\"/\"recipient\").\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function deriveKey({ secret, producerInfo, consumerInfo }: any) {\n  if (!(secret instanceof Uint8Array && secret.length > 0)) {\n    throw new TypeError('\"secret\" must be a non-empty Uint8Array.');\n  }\n  if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {\n    throw new TypeError('\"producerInfo\" must be a non-empty Uint8Array.');\n  }\n  if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {\n    throw new TypeError('\"consumerInfo\" must be a non-empty Uint8Array.');\n  }\n\n  // the output of Concat KDF is hash(roundNumber || Z || OtherInfo)\n  // where roundNumber is always 1 because the hash length is presumed to\n  // ...match the key length, encoded as a big endian 32-bit integer\n  // where OtherInfo is:\n  // AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo\n  // where SuppPubInfo is the key length in bits, big endian encoded as a\n  // 32-bit number, i.e., 256 === [0, 0, 1, 0]\n  const input = new Uint8Array(\n    4 + // round number\n    secret.length + // `Z`\n    ALGORITHM_ID.length + // AlgorithmID\n    4 +\n    producerInfo.length + // PartyUInfo\n    4 +\n    consumerInfo.length + // PartyVInfo\n      4\n  ); // SuppPubInfo (key data length in bits)\n  let offset = 0;\n  const dv = new DataView(input.buffer, input.byteOffset, input.byteLength);\n  dv.setUint32(offset, 1);\n  input.set(secret, (offset += 4));\n  input.set(ALGORITHM_ID, (offset += secret.length));\n  dv.setUint32((offset += ALGORITHM_ID.length), producerInfo.length);\n  input.set(producerInfo, (offset += 4));\n  dv.setUint32((offset += producerInfo.length), consumerInfo.length);\n  input.set(consumerInfo, (offset += 4));\n  dv.setUint32((offset += consumerInfo.length), KEY_LENGTH);\n\n  // hash input and return result as derived key\n  return new Uint8Array(await crypto.subtle.digest(HASH_ALGORITHM, input));\n}\n","import { default as bs64 } from 'base64url';\nimport { AESKW } from '@stablelib/aes-kw';\n\nexport interface CreateKekOptions {\n  keyData: Uint8Array;\n}\n\nexport interface WrapKeyOptions {\n  unwrappedKey: Uint8Array;\n}\n\nexport interface UnwrapKeyOptions {\n  wrappedKey: string; //base64url\n}\n\nexport class KeyEncryptionKey {\n  public aeskw: AESKW;\n  public algorithm: any;\n\n  static createKek = async ({ keyData }: CreateKekOptions) => {\n    return new KeyEncryptionKey(keyData);\n  };\n\n  constructor(key: Uint8Array) {\n    if (key.length !== 32) {\n      throw new Error('key must be 32 bytes');\n    }\n    this.aeskw = new AESKW(key);\n    this.algorithm = { name: 'A256KW' };\n  }\n\n  /**\n   * Wraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.unwrappedKey - The key material as a\n   *   `Uint8Array`.\n   *\n   * @returns {string} - The base64url-encoded wrapped key bytes.\n   */\n  wrapKey({ unwrappedKey }: WrapKeyOptions): string {\n    const wrappedKey = this.aeskw.wrapKey(unwrappedKey);\n    return bs64.encode(Buffer.from(wrappedKey));\n  }\n\n  /**\n   * Unwraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {string} options.wrappedKey - The wrapped key material as a\n   *   base64url-encoded string.\n   *\n   * @returns {Uint8Array} - Resolves to the key bytes or null if\n   *   the unwrapping fails because the key does not match.\n   */\n  unwrapKey({ wrappedKey }: UnwrapKeyOptions): Uint8Array | null {\n    const _wrappedKey = bs64.toBuffer(wrappedKey);\n    try {\n      return this.aeskw.unwrapKey(_wrappedKey);\n    } catch (e) {\n      // decryption failed\n      console.error(e);\n      return null;\n    }\n  }\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\nimport { XChaCha20Poly1305, KEY_LENGTH } from '@stablelib/xchacha20poly1305';\n\nexport const JWE_ENC = 'XC20P';\n\n/**\n * Generates a content encryption key (CEK). The 256-bit key is intended to be\n * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function generateKey() {\n  // generate content encryption key\n  return crypto.getRandomValues(new Uint8Array(KEY_LENGTH));\n}\n\n/**\n * Encrypts some data. The data will be encrypted using the given\n * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.data - The data to encrypt.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.\n */\nexport async function encrypt({ data, additionalData, cek }: any) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" must be a Uint8Array.');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  const cipher = new XChaCha20Poly1305(cek);\n  // Note: Uses a random value here as a counter is not viable -- multiple\n  // recipients may be trying to update at the same time and use the same\n  // counter breaking security; using XChaCha20Poly1305 once available will\n  // further reduce chances of a collision as it has a 192-bit IV\n  const iv = crypto.getRandomValues(new Uint8Array(cipher.nonceLength));\n\n  // encrypt data\n  const encrypted = cipher.seal(iv, data, additionalData);\n\n  // split ciphertext and tag\n  const ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);\n  const tag = encrypted.subarray(encrypted.length - cipher.tagLength);\n\n  return {\n    ciphertext,\n    iv,\n    tag,\n  };\n}\n\n/**\n * Decrypts some encrypted data. The data must have been encrypted using\n * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.ciphertext - The data to decrypt.\n * @param {Uint8Array} options.iv - The initialization vector (aka nonce).\n * @param {Uint8Array} options.tag - The authentication tag.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<Uint8Array>} The decrypted data.\n */\nexport async function decrypt({\n  ciphertext,\n  iv,\n  tag,\n  additionalData,\n  cek,\n}: any) {\n  if (!(iv instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"iv\".');\n  }\n  if (!(ciphertext instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"ciphertext\".');\n  }\n  if (!(tag instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"tag\".');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  // decrypt `ciphertext`\n  const cipher = new XChaCha20Poly1305(cek);\n  const encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);\n  encrypted.set(ciphertext);\n  encrypted.set(tag, ciphertext.length);\n  return cipher.open(iv, encrypted, additionalData);\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\nimport * as recAlgorithm from './algorithms/recommended';\nimport { stringToUint8Array } from './util';\n\nconst CIPHER_ALGORITHMS: any = {\n  [recAlgorithm.cipher.JWE_ENC]: recAlgorithm.cipher,\n};\n\nexport class DecryptTransformer {\n  public keyAgreementKey: any;\n  public KeyPairClass: any;\n\n  constructor({ keyAgreementKey, KeyPairClass }: any = {}) {\n    if (!keyAgreementKey) {\n      throw new TypeError('\"keyAgreementKey\" is a required parameter.');\n    }\n    this.KeyPairClass = KeyPairClass;\n    this.keyAgreementKey = keyAgreementKey;\n  }\n\n  async transform(chunk: any, controller: any) {\n    // assumes `chunk` is an object with a JWE under the `jwe` property\n    if (!(chunk && typeof chunk === 'object')) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    const { jwe } = chunk;\n\n    const data = await this.decrypt(jwe);\n    if (data === null) {\n      const error = new Error('Invalid decryption key.');\n      error.name = 'DataError';\n      throw error;\n    }\n\n    controller.enqueue(data);\n  }\n\n  async decrypt(jwe: any) {\n    // validate JWE\n    if (!(jwe && typeof jwe === 'object')) {\n      throw new TypeError('\"jwe\" must be an object.');\n    }\n    if (typeof jwe.protected !== 'string') {\n      throw new TypeError('\"jwe.protected\" is missing or not a string.');\n    }\n    if (typeof jwe.iv !== 'string') {\n      throw new Error('Invalid or missing \"iv\".');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n      throw new Error('Invalid or missing \"ciphertext\".');\n    }\n    if (typeof jwe.tag !== 'string') {\n      throw new Error('Invalid or missing \"tag\".');\n    }\n\n    // validate encryption header\n    let header;\n    let additionalData;\n    try {\n      // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n      additionalData = stringToUint8Array(jwe.protected);\n      header = JSON.parse(base64url.toBuffer(jwe.protected).toString());\n    } catch (e) {\n      throw new Error('Invalid JWE \"protected\" header.');\n    }\n    if (!(header.enc && typeof header.enc === 'string')) {\n      throw new Error('Invalid JWE \"enc\" header.');\n    }\n    const cipher = CIPHER_ALGORITHMS[header.enc];\n    if (!cipher) {\n      throw new Error('Unsupported encryption algorithm \"${header.enc}\".');\n    }\n    if (!Array.isArray(jwe.recipients)) {\n      throw new TypeError('\"jwe.recipients\" must be an array.');\n    }\n\n    // find `keyAgreementKey` matching recipient\n    const { keyAgreementKey } = this;\n\n    const _findRecipient = (recipients: any, key: any) => {\n      return recipients.find(\n        (rec: any) =>\n          (rec.header && rec.header.kid === key.id) ||\n          rec.header.kid.split('#').pop() === key.id.split('#').pop()\n      );\n    };\n\n    const recipient = _findRecipient(jwe.recipients, keyAgreementKey);\n\n    if (!recipient) {\n      console.log(jwe.recipients, keyAgreementKey);\n      throw new Error('No matching recipient found for key agreement key.');\n    }\n    // get wrapped CEK\n    const { encrypted_key: wrappedKey } = recipient;\n    if (typeof wrappedKey !== 'string') {\n      throw new Error('Invalid or missing \"encrypted_key\".');\n    }\n\n    // TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping\n    // calls which may even need to hit the network (e.g., Web KMS)\n\n    // derive KEK and unwrap CEK\n    const { epk } = recipient.header;\n\n    const { kek } = await this.KeyPairClass.kekFromEphemeralPeer({\n      keyAgreementKey,\n      epk,\n    });\n    const cek = await kek.unwrapKey({ wrappedKey });\n    if (!cek) {\n      // failed to unwrap key\n      return null;\n    }\n\n    // decrypt content\n    const { ciphertext, iv, tag } = jwe;\n    return cipher.decrypt({\n      ciphertext: base64url.toBuffer(ciphertext),\n      iv: base64url.toBuffer(iv),\n      tag: base64url.toBuffer(tag),\n      additionalData,\n      cek,\n    });\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\n// 1 MiB = 1048576\nconst DEFAULT_CHUNK_SIZE = 1048576;\n\nexport class EncryptTransformer {\n  public recipients: any;\n  public encodedProtectedHeader: any;\n  public cipher: any;\n  public additionalData: any;\n  public cek: any;\n  public chunkSize: any;\n  public offset: any;\n  public totalOffset: any;\n  public index: any;\n  public buffer: any;\n\n  constructor({\n    recipients,\n    encodedProtectedHeader,\n    cipher,\n    additionalData,\n    cek,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  }: any = {}) {\n    this.recipients = recipients;\n    this.encodedProtectedHeader = encodedProtectedHeader;\n    this.cipher = cipher;\n    this.additionalData = additionalData;\n    this.cek = cek;\n    this.chunkSize = chunkSize;\n    this.offset = 0;\n    this.totalOffset = 0;\n    this.index = 0;\n  }\n\n  start() {\n    this.buffer = new Uint8Array(this.chunkSize);\n  }\n\n  async transform(chunk: any, controller: any) {\n    const { buffer } = this;\n\n    // assumes `chunk` is a Uint8Array...\n    if (!(chunk instanceof Uint8Array)) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    while (chunk) {\n      const space = buffer.length - this.offset;\n      if (chunk.length <= space) {\n        buffer.set(chunk, this.offset);\n        this.offset += chunk.byteLength;\n        this.totalOffset += chunk.byteLength;\n        chunk = null;\n      } else {\n        const partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);\n        chunk = new Uint8Array(\n          chunk.buffer,\n          chunk.byteOffset + space,\n          chunk.length - space\n        );\n        buffer.set(partial, this.offset);\n        this.offset += space;\n        this.totalOffset += space;\n      }\n\n      // flush if buffer is full and more data remains\n      if (chunk) {\n        await this.flush(controller);\n      }\n    }\n  }\n\n  async flush(controller: any) {\n    if (this.offset === 0) {\n      // nothing to flush\n      return;\n    }\n\n    // encrypt data\n    const { buffer } = this;\n    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, this.offset);\n    const jwe = await this.encrypt(data);\n\n    // clear buffer\n    this.offset = 0;\n\n    controller.enqueue({\n      index: this.index++,\n      offset: this.totalOffset,\n      jwe,\n    });\n  }\n\n  async encrypt(data: any) {\n    const { cipher, additionalData, cek } = this;\n    const { ciphertext, iv, tag } = await cipher.encrypt({\n      data,\n      additionalData,\n      cek,\n    });\n\n    // represent encrypted data as JWE\n    const jwe = {\n      protected: this.encodedProtectedHeader,\n      recipients: this.recipients,\n      iv: base64url.encode(iv),\n      ciphertext: base64url.encode(ciphertext),\n      tag: base64url.encode(tag),\n    };\n    return jwe;\n  }\n}\n","import { types } from '@transmute/did-key-common';\n\nexport const getEpkGenerator = (KeyPair: types.KeyPairClass, opts: any) => {\n  const generateEphemeralKeyPair = async (): Promise<types.EpkResult> => {\n    const k0 = await KeyPair.generate(opts);\n    const keypair = await k0.toJsonWebKeyPair(true);\n\n    return {\n      keypair,\n      epk: keypair.publicKeyJwk,\n    };\n  };\n  return generateEphemeralKeyPair;\n};\n","import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport canonicalize from 'canonicalize';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key  */\nexport interface ISecp256k1PrivateKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key  */\nexport interface ISecp256k1PublicKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on Jwk.\n */\nexport const getKid = (\n  jwk: ISecp256k1PrivateKeyJwk | ISecp256k1PublicKeyJwk\n) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyHex = (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyHex = (publicKeyHex: string) => {\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    const keyBin = secp256k1.publicKeyConvert(\n      Buffer.from(publicKeyHex, 'hex'),\n      false\n    );\n    key = Buffer.from(keyBin).toString('hex');\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJwk = (jwk: ISecp256k1PrivateKeyJwk) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n\n  const compressed = secp256k1.publicKeyConvert(\n    Buffer.from(uncompressedPublicKey, 'hex'),\n    true\n  );\n  return Buffer.from(compressed).toString('hex');\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PrivateKeyJwk) => {\n  const privateKeyHex = privateKeyHexFromJwk(jwk);\n  return Buffer.from(privateKeyHex, 'hex');\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const publicKeyHex = publicKeyHexFromJwk(jwk);\n  return Buffer.from(publicKeyHex, 'hex');\n};\n\n/** convert publicKeyHex to base58 */\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n\n/** convert publicKeyHex to base58 */\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const privateKeyUInt8ArrayFromPrivateKeyBase58 = (\n  privateKeyBase58: string\n) => {\n  return bs58.decode(privateKeyBase58);\n};\n\nexport const publicKeyUInt8ArrayFromPublicKeyBase58 = (\n  publicKeyBase58: string\n) => {\n  return bs58.decode(publicKeyBase58);\n};\n\nexport const publicKeyHexFromPrivateKeyHex = (privateKeyHex: string) => {\n  const publicKey = secp256k1.publicKeyCreate(\n    new Uint8Array(Buffer.from(privateKeyHex, 'hex'))\n  );\n  return Buffer.from(publicKey).toString('hex');\n};\n","import bs58 from 'bs58';\n\nimport {\n  convertPublicKeyToX25519,\n  convertSecretKeyToX25519,\n} from '@stablelib/ed25519';\nimport * as x25519 from '@stablelib/x25519';\nimport * as keyUtils from './keyUtils';\n\nimport base64url from 'base64url';\nimport crypto from 'crypto';\n\nimport * as common from '@transmute/did-key-common';\n\nimport {\n  deriveKey,\n  getEpkGenerator,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\nconst KEY_TYPE = 'X25519KeyAgreementKey2019';\n\n@common.types.staticImplements<common.types.KeyAgreementKeyPairClass>()\nexport class X25519KeyPair implements common.types.KeyPairInstance {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  public static JWE_ALG: common.types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (keypair as common.types.KeyPairJwk).publicKeyJwk\n        )\n      );\n    }\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xec;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: common.types.KeyPairGenerateOptions) {\n    let key;\n\n    key = x25519.generateKeyPair({\n      isAvailable: true,\n      randomBytes: options.secureRandom,\n    });\n\n    if (!key) {\n      throw new Error('options.seed or options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    return new X25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as common.types.KeyPairBase58);\n  }\n\n  static async generateEphemeralKeyPair(): Promise<common.types.EpkResult> {\n    return getEpkGenerator(X25519KeyPair, {\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    })();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: common.types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // decode public key material\n    const publicKey = base64url.toBuffer(epk.x);\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = {\n      type: KEY_TYPE,\n      publicKeyBase58: bs58.encode(publicKey),\n    };\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = publicKey;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as common.types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey,\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: common.types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    // TODO: consider accepting JWK format for `staticPublicKey` not just LD key\n    if (\n      !(\n        staticPublicKey.type === 'X25519KeyAgreementKey2019' ||\n        staticPublicKey.type === 'JsonWebKey2020'\n      )\n    ) {\n      throw new Error(\n        `\"staticPublicKey.type\" must be \"X25519KeyAgreementKey2019\".`\n      );\n    }\n\n    const epkPair = await X25519KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    if (buffer[0] === 0xec && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new X25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      } as common.types.KeyPairBase58);\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  static fromEdKeyPair(ed25519KeyPair: common.types.KeyPairBase58) {\n    let publicKeyBase58;\n    let privateKeyBase58;\n\n    if (ed25519KeyPair.publicKeyBase58) {\n      publicKeyBase58 = bs58.encode(\n        convertPublicKeyToX25519(bs58.decode(ed25519KeyPair.publicKeyBase58))\n      );\n    }\n\n    if (ed25519KeyPair.privateKeyBase58) {\n      privateKeyBase58 = bs58.encode(\n        convertSecretKeyToX25519(bs58.decode(ed25519KeyPair.privateKeyBase58))\n      );\n    }\n\n    return new X25519KeyPair({\n      controller: ed25519KeyPair.controller,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as common.types.KeyPairBase58);\n  }\n\n  static from(options: common.types.KeyPairBase58 | common.types.KeyPairJwk) {\n    let privateKeyBase58;\n    let publicKeyBase58;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      publicKeyBase58 = (options as common.types.KeyPairBase58).publicKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      privateKeyBase58 = (options as common.types.KeyPairBase58)\n        .privateKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairJwk).privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        (options as common.types.KeyPairJwk).privateKeyJwk\n      );\n    }\n\n    if ((options as common.types.KeyPairJwk).publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        (options as common.types.KeyPairJwk).publicKeyJwk\n      );\n    }\n\n    return new X25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: common.types.KeyPairJwk | common.types.KeyPairBase58) {\n    this.type = 'X25519KeyAgreementKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode((options as common.types.KeyPairBase58).publicKeyBase58)\n      );\n    } else if ((options as common.types.JsonWebKeyPair).publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.publicKeyBase58FromPublicKeyJwk(\n            (options as common.types.JsonWebKeyPair).publicKeyJwk\n          )\n        )\n      );\n    } else {\n      throw new Error(\n        'X25519KeyPair requires publicKeyBase58 or publicKeyJwk, received none.'\n      );\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode((options as common.types.KeyPairBase58).privateKeyBase58)\n      );\n    }\n\n    if ((options as common.types.JsonWebKeyPair).privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.privateKeyBase58FromPrivateKeyJwk(\n            (options as common.types.JsonWebKeyPair).privateKeyJwk\n          )\n        )\n      );\n    }\n\n    if (!this.id) {\n      this.id = `#${this.fingerprint()}`;\n    }\n  }\n\n  fingerprint() {\n    return X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let publicKeyBuffer = this.publicKeyBuffer;\n\n    // validate the first two multicodec bytes 0xec01\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ec01' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toKeyPair(_private: boolean = false): common.types.LinkedDataKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (_private) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(_private: boolean = false): common.types.JsonWebKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (_private) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n\n  toJwk(_private: boolean = false) {\n    const publicKeyBase58 = bs58.encode(this.publicKeyBuffer);\n    if (_private) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        publicKeyBase58,\n        bs58.encode(this.privateKeyBuffer)\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(publicKeyBase58);\n  }\n\n  deriveSecret(options: common.types.DeriveSecretOptions) {\n    let remotePubkeyBytes;\n\n    const { publicKey } = options;\n\n    if ((publicKey as any).publicKeyBase58) {\n      remotePubkeyBytes = bs58.decode(\n        (publicKey as common.types.LinkedDataKeyPair).publicKeyBase58\n      );\n    } else if ((publicKey as any).publicKeyJwk) {\n      remotePubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (publicKey as common.types.JsonWebKeyPair).publicKeyJwk\n        )\n      );\n    }\n\n    const privateKeyBytes = this.privateKeyBuffer as Buffer;\n\n    const scalarMultipleResult = x25519.sharedKey(\n      new Uint8Array(privateKeyBytes),\n      new Uint8Array(remotePubkeyBytes),\n      true\n    );\n\n    return scalarMultipleResult;\n  }\n}\n","/* eslint-disable */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost'\n    // [::1] is the IPv6 localhost address.\n    || window.location.hostname === '[::1]'\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    || window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service '\n              + 'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all '\n                  + 'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404\n        || (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import { createAction } from 'redux-actions';\n\nexport const setUniversalWalletProp = createAction(\n  'universal-wallet/SET_UNIVERSAL_WALLET_PROP',\n  (payload) => payload\n);\n","import { handleActions } from \"redux-actions\";\nimport { setUniversalWalletProp } from \"./actions\";\n\nconst initialState = {\n  name: \"UniversalWallet2020\",\n  status: \"UNLOCKED\",\n  contents: [],\n  vaultEndpoint: \"https://edv.did.ai/edvs\",\n  isSyncEnabled: true,\n  isSyncing: false,\n};\n\nexport default handleActions(\n  {\n    [setUniversalWalletProp]: (state, { payload }) => ({\n      ...state,\n      ...payload,\n    }),\n  },\n  initialState\n);\n","import { connect } from 'react-redux';\nimport * as actions from './actions';\n\nexport default connect(({ wallet }) => ({ wallet }), { ...actions });\n","import reducer from './reducer';\nimport container from './container';\n\nexport default {\n  reducer,\n  container,\n};\n","import { compose } from 'recompose';\nimport withRedux from './redux';\nimport withHandlers from './handlers';\n\nexport default compose(withRedux, withHandlers);\n","import { connectRouter } from \"connected-react-router\";\n\nimport history from \"./history\";\n\nimport wallet from \"./universal-wallet\";\n\nexport default {\n  router: connectRouter(history),\n  wallet: wallet.reducer,\n};\n","import React from \"react\";\n\nimport ToggleButton from \"@material-ui/lab/ToggleButton\";\nimport ToggleButtonGroup from \"@material-ui/lab/ToggleButtonGroup\";\n\nexport default function ToggleButtons({ onClick }) {\n  const [alignment, setAlignment] = React.useState(\"left\");\n\n  const handleAlignment = (event, newAlignment) => {\n    setAlignment(newAlignment);\n  };\n\n  return (\n    <ToggleButtonGroup\n      value={alignment}\n      exclusive\n      onChange={handleAlignment}\n      aria-label=\"did document representation\"\n    >\n      <ToggleButton\n        value=\"left\"\n        aria-label=\"json\"\n        onClick={() => {\n          onClick(\"did+json\");\n        }}\n      >\n        did+json\n      </ToggleButton>\n      <ToggleButton\n        value=\"right\"\n        aria-label=\"jsonld\"\n        onClick={() => {\n          onClick(\"did+ld+json\");\n        }}\n      >\n        did+ld+json\n      </ToggleButton>\n      <ToggleButton value=\"justify\" aria-label=\"cbor\" disabled>\n        did+cbor\n      </ToggleButton>\n    </ToggleButtonGroup>\n  );\n}\n","import crypto from \"crypto\";\nimport * as ed25519 from \"@transmute/did-key-ed25519\";\nimport * as x25519 from \"@transmute/did-key-x25519\";\nimport * as secp256k1 from \"@transmute/did-key-secp256k1\";\nimport * as bls12381 from \"@transmute/did-key-bls12381\";\nimport * as didKeyWebCrypto from \"@transmute/did-key-web-crypto\";\n\nexport const generateEd25519 = async (keys, contentType) => {\n  let _keys = keys;\n  let ed25519Key;\n  let x25519Key;\n  if (keys !== null) {\n    ed25519Key = await ed25519.Ed25519KeyPair.from(_keys.ed25519);\n    x25519Key = await x25519.X25519KeyPair.from(_keys.x25519);\n  } else {\n    ed25519Key = await ed25519.Ed25519KeyPair.generate({\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    });\n    x25519Key = await x25519.X25519KeyPair.fromEdKeyPair(\n      await ed25519Key.toKeyPair(true)\n    );\n  }\n  _keys = {\n    ed25519:\n      contentType === \"application/did+ld+json\"\n        ? await ed25519Key.toKeyPair(true)\n        : await ed25519Key.toJsonWebKeyPair(true),\n    x25519:\n      contentType === \"application/did+ld+json\"\n        ? await x25519Key.toKeyPair(true)\n        : await x25519Key.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await ed25519.driver.resolve(\n    _keys.ed25519.controller,\n    {\n      accept: contentType,\n    }\n  );\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateX25519 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = await x25519.X25519KeyPair.from(keys.key);\n  } else {\n    keyPair = await x25519.X25519KeyPair.generate({\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    });\n  }\n  _keys = {\n    key:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.toKeyPair(true)\n        : await keyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await x25519.driver.resolve(_keys.key.controller, {\n    accept: contentType,\n  });\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateSecp256k1 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = await secp256k1.Secp256k1KeyPair.from(keys.key);\n  } else {\n    keyPair = await secp256k1.Secp256k1KeyPair.generate({\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    });\n  }\n  _keys = {\n    key:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.toKeyPair(true)\n        : await keyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await secp256k1.driver.resolve(_keys.key.controller, {\n    accept: contentType,\n  });\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateBls12381 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = new bls12381.Bls12381KeyPairs({\n      id: keys.g1.controller.split('did:key:').pop(),\n      controller: keys.g1.controller,\n      g1KeyPair: await bls12381.Bls12381G1KeyPair.from(keys.g1),\n      g2KeyPair: await bls12381.Bls12381G2KeyPair.from(keys.g2)\n    });\n  } else {\n    keyPair = await bls12381.Bls12381KeyPairs.generate();\n  }\n  _keys = {\n    g1:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.g1KeyPair.toKeyPair(true)\n        : await keyPair.g1KeyPair.toJsonWebKeyPair(true),\n    g2:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.g2KeyPair.toKeyPair(true)\n        : await keyPair.g2KeyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await bls12381.driver.resolve(_keys.g1.controller, {\n    accept: contentType,\n  });\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateP256 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = await didKeyWebCrypto.KeyPair.from(keys.key);\n  } else {\n    keyPair = await didKeyWebCrypto.KeyPair.generate({\n      kty: \"EC\",\n      crvOrSize: \"P-256\",\n    });\n  }\n  _keys = {\n    key:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.toKeyPair(true)\n        : await keyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await didKeyWebCrypto.driver.resolve(\n    _keys.key.controller,\n    {\n      accept: contentType,\n    }\n  );\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateP384 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = await didKeyWebCrypto.KeyPair.from(keys.key);\n  } else {\n    keyPair = await didKeyWebCrypto.KeyPair.generate({\n      kty: \"EC\",\n      crvOrSize: \"P-384\",\n    });\n  }\n  _keys = {\n    key:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.toKeyPair(true)\n        : await keyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await didKeyWebCrypto.driver.resolve(\n    _keys.key.controller,\n    {\n      accept: contentType,\n    }\n  );\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n\nexport const generateP521 = async (keys, contentType) => {\n  let _keys = keys;\n  let keyPair;\n  if (_keys !== null) {\n    keyPair = await didKeyWebCrypto.KeyPair.from(keys.key);\n  } else {\n    keyPair = await didKeyWebCrypto.KeyPair.generate({\n      kty: \"EC\",\n      crvOrSize: \"P-521\",\n    });\n  }\n  _keys = {\n    key:\n      contentType === \"application/did+ld+json\"\n        ? await keyPair.toKeyPair(true)\n        : await keyPair.toJsonWebKeyPair(true),\n  };\n  const { didDocument } = await didKeyWebCrypto.driver.resolve(\n    _keys.key.controller,\n    {\n      accept: contentType,\n    }\n  );\n  return {\n    keys: _keys,\n    didDocument,\n  };\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Tabs from \"@material-ui/core/Tabs\";\nimport Tab from \"@material-ui/core/Tab\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Box from \"@material-ui/core/Box\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Button from \"@material-ui/core/Button\";\nimport ContentTypeToggle from \"./ContentTypeToggle\";\nimport { DIDDocumentPreview, JSONEditor } from \"@transmute/material-did-core\";\n\nimport {\n  generateEd25519,\n  generateX25519,\n  generateSecp256k1,\n  generateBls12381,\n  generateP256,\n  generateP384,\n  generateP521,\n} from \"./util\";\n\nfunction TabPanel(props) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`vertical-tabpanel-${index}`}\n      aria-labelledby={`vertical-tab-${index}`}\n      {...other}\n    >\n      {value === index && <Box p={3}>{children}</Box>}\n    </div>\n  );\n}\n\nTabPanel.propTypes = {\n  children: PropTypes.node,\n  index: PropTypes.any.isRequired,\n  value: PropTypes.any.isRequired,\n};\n\nfunction a11yProps(index) {\n  return {\n    id: `vertical-tab-${index}`,\n    \"aria-controls\": `vertical-tabpanel-${index}`,\n  };\n}\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n    backgroundColor: theme.palette.background.paper,\n    display: \"flex\",\n  },\n  tabs: {\n    borderRight: `1px solid ${theme.palette.divider}`,\n  },\n}));\n\nconst Panel = ({ keys, didDocument, onToggleRepresentation, onGenerate }) => {\n  return (\n    <Grid container spacing={4}>\n      <Grid item sm={12} xs={12}>\n        <Box display=\"flex\">\n          <Box flexGrow={1}>\n            <ContentTypeToggle\n              onClick={(data) => {\n                onToggleRepresentation(data);\n              }}\n            />\n          </Box>\n          <Box>\n            <Button\n              variant={\"contained\"}\n              color={\"secondary\"}\n              onClick={() => {\n                onGenerate();\n              }}\n            >\n              Generate\n            </Button>\n          </Box>\n        </Box>\n      </Grid>\n      {didDocument !== null && (\n        <Grid item sm={12} xs={12}>\n          <Typography variant={\"h6\"} gutterBottom>\n            DID Document\n          </Typography>\n          <DIDDocumentPreview didDocument={didDocument} />\n        </Grid>\n      )}\n      <Grid item sm={12} xs={12}>\n        <Typography variant={\"h6\"} gutterBottom>\n          Key\n        </Typography>\n        <JSONEditor value={JSON.stringify(keys, null, 2)} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default function VerticalTabs() {\n  const classes = useStyles();\n  const [state, setState] = React.useState({\n    contentType: \"application/did+json\",\n    keys: null,\n    didDocument: null,\n  });\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const options = [\n    {\n      index: 0,\n      name: \"ed25519\",\n      refresh: generateEd25519,\n    },\n    {\n      index: 1,\n      name: \"x25519\",\n      refresh: generateX25519,\n    },\n    {\n      index: 2,\n      name: \"secp256k1\",\n      refresh: generateSecp256k1,\n    },\n    {\n      index: 3,\n      name: \"bls12381\",\n      refresh: generateBls12381,\n    },\n    {\n      index: 4,\n      name: \"P-256\",\n      refresh: generateP256,\n    },\n    {\n      index: 5,\n      name: \"P-384\",\n      refresh: generateP384,\n    },\n    {\n      index: 6,\n      name: \"P-521\",\n      refresh: generateP521,\n    },\n  ];\n\n  const handleGenerate = async (index) => {\n    const refresh = options[index].refresh;\n    const { keys, didDocument } = await refresh(null, state.contentType);\n    setState({\n      ...state,\n      keys,\n      didDocument,\n    });\n  };\n\n  React.useEffect(() => {\n    (async () => {\n      handleGenerate(0);\n    })();\n  }, []);\n\n  return (\n    <div className={classes.root}>\n      <Tabs\n        orientation=\"vertical\"\n        variant=\"scrollable\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"DID Types\"\n        className={classes.tabs}\n      >\n        {options.map((opt) => {\n          return (\n            <Tab\n              key={opt.index}\n              label={opt.name}\n              {...a11yProps(opt.index)}\n              onClick={() => {\n                handleGenerate(opt.index);\n              }}\n            />\n          );\n        })}\n      </Tabs>\n      {options.map((opt) => {\n        return (\n          <TabPanel\n            key={opt.index}\n            value={value}\n            index={opt.index}\n            style={{ width: \"100%\" }}\n          >\n            <Panel\n              didDocument={state.didDocument}\n              keys={state.keys}\n              onToggleRepresentation={async (contentType) => {\n                const refresh = options[opt.index].refresh;\n                const { keys, didDocument } = await refresh(\n                  state.keys,\n                  `application/${contentType}`\n                );\n                setState({\n                  contentType: `application/${contentType}`,\n                  keys,\n                  didDocument,\n                });\n              }}\n              onGenerate={async () => {\n                handleGenerate(opt.index);\n              }}\n            />\n          </TabPanel>\n        );\n      })}\n    </div>\n  );\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport Base from \"../base/base\";\n\nimport VerticalTabs from \"./VerticalTabs\";\n\nexport const Home = () => {\n  return (\n    <Base>\n      <VerticalTabs />\n    </Base>\n  );\n};\n\nHome.propTypes = {};\n","import React from \"react\";\nimport { Home as Page } from \"./Home\";\n\nimport { compose } from \"redux\";\n\nimport wallet from \"../../store/universal-wallet\";\n\nconst container = compose(wallet.container);\n\nexport const Home = container((props) => {\n  return <Page {...props} />;\n});\n","import { driver as ed25519Driver } from '@transmute/did-key-ed25519';\nimport { driver as x25519Driver } from '@transmute/did-key-x25519';\nimport { driver as bls12381Driver } from '@transmute/did-key-bls12381';\nimport { driver as secp256k1Driver } from '@transmute/did-key-secp256k1';\nimport { driver as didWebDriver } from '@transmute/did-key-web-crypto';\n\nconst prefixToDriverMap: any = {\n  z6Mk: ed25519Driver,\n  z6LS: x25519Driver,\n  zUC7: bls12381Driver, //g2\n  z3tE: bls12381Driver, //g1\n  z5Tc: bls12381Driver, //g1andg2\n  zQ3s: secp256k1Driver,\n  zXwp: didWebDriver,\n  zACH: didWebDriver,\n  zJss: didWebDriver,\n};\n\nexport const resolver = {\n  resolve: async (\n    didUrl: string,\n    resolutionMetaData: any = { accept: 'application/did+ld+json' }\n  ) => {\n    if (didUrl.indexOf('did:key:') !== 0) {\n      throw new Error('did must be of method did:key.');\n    }\n    const idchar: any = didUrl.split('did:key:').pop();\n    const encodedType = idchar.substring(0, 4);\n    try {\n      const result = await prefixToDriverMap[encodedType].resolve(\n        didUrl,\n        resolutionMetaData\n      );\n      return result;\n    } catch (e) {\n      throw new Error('Unknown DID Key type: ' + encodedType);\n    }\n  },\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport Base from \"../base/base\";\nimport Grid from \"@material-ui/core/Grid\";\nimport {resolver} from \"@transmute/did-key.js\"\nimport { DIDDocumentPreview } from \"@transmute/material-did-core\";\nimport ContentTypeToggle from '../home/ContentTypeToggle'\n\nexport const Resolver = (props) => {\n  const [didDoc, setDidDoc] = React.useState({})\n  React.useEffect(()=>{\n    (async ()=>{\n \n      const { didDocument } = await resolver.resolve(props.match.params.did, {\n        accept: 'application/did+json',\n      });\n      setDidDoc(didDocument);\n    })();\n  }, [])\n\n  const onToggleRepresentation = async (representation)=>{\n    const { didDocument } = await resolver.resolve(props.match.params.did, {\n      accept: `application/${representation}`,\n    });\n    setDidDoc(didDocument);\n  }\n\n\n  return (\n    <Base>\n    <Grid container spacing={2}>\n      <Grid item xs={12}>\n      <ContentTypeToggle\n        onClick={(data) => {\n          onToggleRepresentation(data);\n        }}\n      />\n      </Grid>\n      <Grid item xs={12}>\n      {didDoc.id ? <DIDDocumentPreview didDocument={didDoc} /> : <div>No did document.</div>}\n      </Grid>\n    </Grid>\n    </Base>\n  );\n};\n\nResolver.propTypes = {};\n","import React from \"react\";\nimport { Resolver as Page } from \"./Resolver\";\n\nimport { compose } from \"redux\";\n\nimport wallet from \"../../store/universal-wallet\";\n\nconst container = compose(wallet.container);\n\nexport const Resolver = container((props) => {\n  return <Page {...props} />;\n});\n","import { Home } from \"./home\";\nimport { Resolver } from \"./resolver\";\n// import { Workbench } from \"./workbench\";\n// import { PdfDemo } from \"./pdf\";\n// import { Videos } from \"./videos\";\nimport { Unextractable } from './unextractable'\n\nexport const routes = [\n  { path: \"/\", exact: true, component: Home },\n  { path: \"/:did\", exact: true, component: Resolver },\n  { path: \"/unextractable\", exact: true, component: Unextractable },\n\n  // { path: \"/workbench\", exact: true, component: Workbench },\n  // { path: \"/offline\", exact: true, component: PdfDemo },\n  // { path: \"/videos\", exact: true, component: Videos },\n];\n","import React from \"react\";\nimport { Unextractable as Page } from \"./Unextractable\";\n\nimport { compose } from \"redux\";\n\nimport wallet from \"../../store/universal-wallet\";\n\nconst container = compose(wallet.container);\n\nexport const Unextractable = container((props) => {\n  return <Page {...props} />;\n});\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport Particles from 'react-particles-js';\n\nexport class ParticlesContainer extends Component {\n  render() {\n    const params = this.props.params || {\n      particles: {\n        line_linked: {\n          shadow: {\n            enable: true,\n            color: '#3CA9D1',\n            blur: 5,\n          },\n        },\n      },\n    };\n    return (\n      <React.Fragment>\n        <div\n          style={{\n            zIndex: 2,\n            position: 'absolute',\n          }}\n        >\n          {this.props.children}\n        </div>\n\n        <Particles\n          className=\"Particles\"\n          style={{\n            zIndex: 1,\n            top: 0,\n            position: 'absolute',\n          }}\n          params={params}\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nParticlesContainer.propTypes = {\n  params: PropTypes.object,\n  children: PropTypes.any,\n};\n","import React, { Component } from \"react\";\nimport Button from \"@material-ui/core/Button\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Theme from \"../../components/Theme/Theme\";\n\nimport { ParticlesContainer } from \"../../components/ParticlesContainer\";\n\nimport \"./404.css\";\n\nexport class NotFound extends Component {\n  render() {\n    return (\n      <Theme>\n        <div className=\"notFound\">\n          <ParticlesContainer>\n            <div className=\"copy\" style={{ padding: \"32px\" }}>\n              <Typography variant=\"h1\">404</Typography>\n              <Typography>\n                page not found.\n              </Typography>\n              <br />\n              <Button\n                variant=\"contained\"\n                color={\"secondary\"}\n                onClick={() => {\n                  window.location.href = \"/\";\n                }}\n              >\n                Go Home\n              </Button>\n            </div>\n          </ParticlesContainer>\n        </div>\n      </Theme>\n    );\n  }\n}\n\nexport default NotFound;\n","import { createStore, combineReducers, applyMiddleware, compose } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport { routerMiddleware } from \"connected-react-router\";\nimport storage from \"redux-persist/lib/storage\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport thunk from \"redux-thunk\";\nimport withReduxEnhancer from \"addon-redux/enhancer\";\n\nimport rootReducer from \".\";\nimport history from \"./history\";\n\nexport default (appReducers = {}) => {\n  // Persistance configuration\n  const persistConfig = {\n    key: \"root\",\n    whitelist: [\"wallet\"],\n    storage,\n  };\n\n  const middlewares = [thunk, routerMiddleware(history)];\n\n  // TODO: refactor for production\n  if (process.env.NODE_ENV !== \"production\") {\n    // const reduxListener = createStorybookListener();\n    // middlewares.push(reduxListener);\n  }\n\n  // Store.\n  const store = createStore(\n    persistReducer(\n      persistConfig,\n      combineReducers({ ...rootReducer, ...appReducers })\n    ),\n    composeWithDevTools(\n      compose(applyMiddleware(...middlewares), withReduxEnhancer)\n    )\n  );\n\n  // Persistor.\n  const persistor = persistStore(store);\n  return {\n    store,\n    persistor,\n    history,\n  };\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nimport { Switch, Route } from \"react-router-dom\";\nimport { ConnectedRouter } from \"connected-react-router\";\nimport { Provider } from \"react-redux\";\nimport { PersistGate } from \"redux-persist/lib/integration/react\";\n\nimport * as serviceWorker from \"./serviceWorker\";\nimport createStore from \"./store/create\";\nimport { routes } from \"./pages\";\nimport { NotFound } from \"./pages/errors/404\";\n\nconst { store, persistor, history } = createStore();\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate persistor={persistor}>\n      <ConnectedRouter history={history}>\n        <Switch>\n          {routes.map(({ exact, path, component }) => (\n            <Route key={path} exact={exact} path={path} component={component} />\n          ))}\n          <Route path=\"*\" render={() => <NotFound />} />\n        </Switch>\n      </ConnectedRouter>\n    </PersistGate>\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\nconsole.log(\n  `\nHello Developer ! \nCheckout our corporate website if you are interested in working with us: \n https://www.transmute.industries/\n`\n);\n","\n'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./did-key-bls12381.cjs.production.min.js')\n} else {\n  module.exports = require('./did-key-bls12381.cjs.development.js')\n}\n","import { createBrowserHistory } from 'history';\n\nexport default createBrowserHistory();\n","import React from \"react\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Menu from \"@material-ui/core/Menu\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport MoreVertIcon from \"@material-ui/icons/MoreVert\";\nimport HomeIcon from \"@material-ui/icons/Home\";\n\nimport history from \"../../store/history\";\n\nconst StyledMenu = withStyles({\n  paper: {\n    border: \"1px solid #d3d4d5\",\n  },\n})((props) => (\n  <Menu\n    elevation={0}\n    getContentAnchorEl={null}\n    anchorOrigin={{\n      vertical: \"bottom\",\n      horizontal: \"center\",\n    }}\n    transformOrigin={{\n      vertical: \"top\",\n      horizontal: \"center\",\n    }}\n    {...props}\n  />\n));\n\nconst StyledMenuItem = withStyles((theme) => ({\n  root: {\n    \"&:focus\": {\n      backgroundColor: theme.palette.primary.main,\n      \"& .MuiListItemIcon-root, & .MuiListItemText-primary\": {\n        color: theme.palette.common.white,\n      },\n    },\n  },\n}))(MenuItem);\n\nexport default function CustomizedMenus() {\n  const [anchorEl, setAnchorEl] = React.useState(null);\n\n  const handleClick = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  return (\n    <div>\n      <IconButton\n        color={\"inherit\"}\n        aria-controls=\"customized-menu\"\n        aria-haspopup=\"true\"\n        onClick={handleClick}\n      >\n        <MoreVertIcon />\n      </IconButton>\n      <StyledMenu\n        id=\"customized-menu\"\n        anchorEl={anchorEl}\n        keepMounted\n        open={Boolean(anchorEl)}\n        onClose={handleClose}\n      >\n        <StyledMenuItem\n          onClick={() => {\n            history.push(\"/\");\n          }}\n        >\n          <ListItemIcon>\n            <HomeIcon fontSize=\"small\" />\n          </ListItemIcon>\n          <ListItemText primary=\"Home\" />\n        </StyledMenuItem>\n      </StyledMenu>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport HomeIcon from \"@material-ui/icons/Home\";\nimport HttpIcon from \"@material-ui/icons/Http\";\nimport CodeIcon from \"@material-ui/icons/Code\";\nimport GavelIcon from \"@material-ui/icons/Gavel\";\nimport BuildIcon from \"@material-ui/icons/Build\";\nimport PictureAsPdfIcon from \"@material-ui/icons/PictureAsPdf\";\nimport YouTubeIcon from \"@material-ui/icons/YouTube\";\nimport history from \"../../store/history\";\n\nexport default function DrawerContent() {\n  return (\n    <List>\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/\");\n        }}\n      >\n        <ListItemIcon>\n          <HomeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Home\"} />\n      </ListItem>\n\n      {/* Need to update vc.js to support better key structure.*/}\n\n      {/* <ListItem\n        button\n        onClick={() => {\n          history.push(\"/workbench\");\n        }}\n      >\n        <ListItemIcon>\n          <BuildIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Workbench\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/offline\");\n        }}\n      >\n        <ListItemIcon>\n          <PictureAsPdfIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"PDF Demo\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/videos\");\n        }}\n      >\n        <ListItemIcon>\n          <YouTubeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Videos\"} />\n      </ListItem> */}\n\n      <ListItem\n        button\n        onClick={() => {\n          window.open(\"https://w3c-ccg.github.io/did-method-key/\");\n        }}\n      >\n        <ListItemIcon>\n          <GavelIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Spec\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          window.open(\"https://github.com/transmute-industries/did-key.js\");\n        }}\n      >\n        <ListItemIcon>\n          <CodeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Code\"} />\n      </ListItem>\n    </List>\n  );\n}\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { makeStyles, useTheme } from \"@material-ui/core/styles\";\nimport Drawer from \"@material-ui/core/Drawer\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\n\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\n\nimport Divider from \"@material-ui/core/Divider\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport MenuIcon from \"@material-ui/icons/Menu\";\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\n\nimport Theme from \"../../components/Theme/Theme\";\nimport logo from \"../../assets/logo.svg\";\n\nimport Menu from \"./menu\";\nimport DrawerContent from \"./drawer\";\n\nconst drawerWidth = 240;\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: \"flex\",\n    width: \"100%\",\n  },\n  appBar: {\n    zIndex: theme.zIndex.drawer + 1,\n    transition: theme.transitions.create([\"width\", \"margin\"], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n  },\n  appBarShift: {\n    marginLeft: drawerWidth,\n    width: `calc(100% - ${drawerWidth}px)`,\n    transition: theme.transitions.create([\"width\", \"margin\"], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n  },\n  menuButton: {\n    marginRight: 36,\n  },\n  hide: {\n    display: \"none\",\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0,\n    whiteSpace: \"nowrap\",\n  },\n  drawerOpen: {\n    width: drawerWidth,\n    transition: theme.transitions.create(\"width\", {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n  },\n  drawerClose: {\n    transition: theme.transitions.create(\"width\", {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n    overflowX: \"hidden\",\n    width: theme.spacing(7) + 1,\n    [theme.breakpoints.up(\"sm\")]: {\n      width: theme.spacing(9) + 1,\n    },\n  },\n  toolbar: {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"flex-end\",\n    padding: theme.spacing(0, 1),\n    // necessary for content to be below app bar\n    ...theme.mixins.toolbar,\n  },\n  content: {\n    flexGrow: 1,\n    padding: theme.spacing(3),\n  },\n}));\n\nexport default function MiniDrawer({ children }) {\n  const classes = useStyles();\n  const theme = useTheme();\n  const [open, setOpen] = React.useState(false);\n\n  const handleDrawerOpen = () => {\n    setOpen(true);\n  };\n\n  const handleDrawerClose = () => {\n    setOpen(false);\n  };\n\n  return (\n    <Theme>\n      <div className={classes.root}>\n        <CssBaseline />\n        <AppBar\n          position=\"fixed\"\n          className={clsx(classes.appBar, {\n            [classes.appBarShift]: open,\n          })}\n        >\n          <Toolbar>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              onClick={handleDrawerOpen}\n              edge=\"start\"\n              className={clsx(classes.menuButton, {\n                [classes.hide]: open,\n              })}\n            >\n              <MenuIcon />\n            </IconButton>\n            <img\n              src={logo}\n              alt={\"logo\"}\n              className={classes.title}\n              style={{ height: \"28px\" }}\n            />\n            <div style={{ flexGrow: 1 }}></div>\n            <Menu />\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          variant=\"permanent\"\n          className={clsx(classes.drawer, {\n            [classes.drawerOpen]: open,\n            [classes.drawerClose]: !open,\n          })}\n          classes={{\n            paper: clsx({\n              [classes.drawerOpen]: open,\n              [classes.drawerClose]: !open,\n            }),\n          }}\n        >\n          <div className={classes.toolbar}>\n            <IconButton onClick={handleDrawerClose}>\n              {theme.direction === \"rtl\" ? (\n                <ChevronRightIcon />\n              ) : (\n                <ChevronLeftIcon />\n              )}\n            </IconButton>\n          </div>\n          <Divider />\n          <DrawerContent />\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          {children}\n        </main>\n      </div>\n    </Theme>\n  );\n}\n","import base64url from 'base64url';\n\nimport * as ed25519 from '@stablelib/ed25519';\n\nimport canonicalize from 'canonicalize';\n\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\nconst _jwkToSecretKey = (jwk: any) => {\n  const d = base64url.toBuffer(jwk.d);\n  const x = base64url.toBuffer(jwk.x);\n  const secretKey = new Uint8Array(Buffer.concat([d, x]));\n  return secretKey;\n};\n\nconst _jwkToPublicKey = (jwk: any) => {\n  const x = base64url.toBuffer(jwk.x);\n  const publicKey = new Uint8Array(x);\n  return publicKey;\n};\n\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n\nexport const sign = (\n  payload: any,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n  return jws;\n};\n\nexport const signDetached = (\n  payload: Buffer,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}..${encodedSignature}`;\n  return jws;\n};\n\nexport const verify = (jws: string, publicKeyJwk: any) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n\n  throw new JWSVerificationFailed('signature verification failed');\n};\n\nexport const verifyDetached = (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: any\n) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n  return verified;\n};\n\nexport default {\n  decode,\n\n  sign,\n  signDetached,\n\n  verify,\n  verifyDetached,\n};\n","import bs58 from 'bs58';\n\nimport * as ed25519 from '@stablelib/ed25519';\nimport * as keyUtils from './keyUtils';\n\nimport * as common from '@transmute/did-key-common';\n\nimport { X25519KeyPair } from '@transmute/did-key-x25519';\n\n@common.types.staticImplements<common.types.KeyPairClass>()\nexport class Ed25519KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (keypair as common.types.KeyPairJwk).publicKeyJwk\n        )\n      );\n    }\n    // ed25519 cryptonyms are multicodec encoded values, specifically:\n    // (multicodec ed25519-pub 0xed01 + key bytes)\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xed;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n  static async generate(options: common.types.KeyPairGenerateOptions) {\n    let key;\n    if (options.secureRandom) {\n      key = ed25519.generateKeyPair({\n        isAvailable: true,\n        randomBytes: options.secureRandom,\n      });\n    } else {\n      throw new Error('options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    return new Ed25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L81\n    if (buffer[0] === 0xed && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new Ed25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n  // todo: consider moving this type conversion cancer to common.\n  static from(options: common.types.KeyPairBase58 | common.types.KeyPairJwk) {\n    let privateKeyBase58;\n    let publicKeyBase58;\n\n    if ((options as common.types.KeyPairBase58).publicKeyBase58) {\n      publicKeyBase58 = (options as common.types.KeyPairBase58).publicKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairBase58).privateKeyBase58) {\n      privateKeyBase58 = (options as common.types.KeyPairBase58)\n        .privateKeyBase58;\n    }\n\n    if ((options as common.types.KeyPairJwk).privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        (options as common.types.KeyPairJwk).privateKeyJwk\n      );\n    }\n\n    if ((options as common.types.KeyPairJwk).publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        (options as common.types.KeyPairJwk).publicKeyJwk\n      );\n    }\n\n    return new Ed25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'Ed25519VerificationKey2018';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      this.publicKeyBuffer = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(options.publicKeyJwk)\n      );\n    } else {\n      throw new Error(\n        'Ed25519KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.'\n      );\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    }\n\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  publicNode() {\n    return this.toKeyPair(false);\n  }\n\n  fingerprint() {\n    return Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n\n    // validate the first two multicodec bytes 0xed01\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ed01' &&\n      this.publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  async toJwk(exportPrivateKey: boolean = false) {\n    if (exportPrivateKey) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        bs58.encode(this.privateKeyBuffer)\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(\n      bs58.encode(this.publicKeyBuffer)\n    );\n  }\n\n  toX25519KeyPair(exportPrivateKey: boolean = false) {\n    if (exportPrivateKey) {\n      return X25519KeyPair.fromEdKeyPair({\n        controller: this.controller,\n        publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n        privateKeyBase58: bs58.encode(this.privateKeyBuffer),\n      } as any);\n    } else {\n      return X25519KeyPair.fromEdKeyPair({\n        controller: this.controller,\n        publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n      } as any);\n    }\n  }\n\n  toKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n\n    if (exportPrivateKey) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: keyUtils.publicKeyJwkFromPublicKeyBase58(\n        bs58.encode(this.publicKeyBuffer)\n      ),\n    };\n\n    delete kp.publicKeyJwk.kid;\n    if (exportPrivateKey) {\n      kp.privateKeyJwk = keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        bs58.encode(this.privateKeyBuffer)\n      );\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n\n  signer() {\n    if (!this.privateKeyBuffer) {\n      throw new Error('No private key to sign with.');\n    }\n    let { privateKeyBuffer } = this;\n    return {\n      async sign({ data }: any) {\n        const signatureUInt8Array = ed25519.sign(privateKeyBuffer, data);\n        return signatureUInt8Array;\n      },\n    };\n  }\n  verifier() {\n    if (!this.publicKeyBuffer) {\n      throw new Error('No public key to verify with.');\n    }\n    let { publicKeyBuffer } = this;\n    return {\n      async verify({ data, signature }: any) {\n        let verified = false;\n        try {\n          verified = ed25519.verify(publicKeyBuffer, data, signature);\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n}\n","import crypto from 'crypto';\n\nimport * as keyUtils from './keyUtils';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport * as common from '@transmute/did-key-common';\n\nconst _generate = (secureRandom: any) => {\n  let privateKey;\n  do {\n    privateKey = secureRandom();\n  } while (!secp256k1.privateKeyVerify(privateKey));\n\n  const publicKey = secp256k1.publicKeyCreate(privateKey);\n  return { publicKey, privateKey };\n};\n\n@common.types.staticImplements<common.types.KeyPairClass>()\nexport class Secp256k1KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = new Uint8Array(\n        Buffer.from(\n          keyUtils.publicKeyHexFromJwk(\n            (keypair as common.types.KeyPairJwk).publicKeyJwk\n          )\n        )\n      );\n    }\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    // See https://github.com/multiformats/multicodec/blob/master/table.csv\n    // 0xe7 is Secp256k1 public key\n    buffer[0] = 0xe7; //\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: any = {}) {\n    let privateKey;\n    let publicKey;\n    if (options.secureRandom) {\n      ({ privateKey, publicKey } = _generate(options.secureRandom));\n    }\n\n    if (!privateKey) {\n      throw new Error('Cannot generate private key.');\n    }\n\n    const publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyHex(\n      Buffer.from(publicKey).toString('hex')\n    );\n    const privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n      Buffer.from(privateKey).toString('hex')\n    );\n\n    const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n\n    return new Secp256k1KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static async from(options: any) {\n    let privateKeyBase58 = options.privateKeyBase58;\n    let publicKeyBase58 = options.publicKeyBase58;\n\n    if (options.privateKeyHex) {\n      privateKeyBase58 = await keyUtils.privateKeyBase58FromPrivateKeyHex(\n        options.privateKeyHex\n      );\n    }\n\n    if (options.publicKeyHex) {\n      publicKeyBase58 = await keyUtils.publicKeyBase58FromPublicKeyHex(\n        options.publicKeyHex\n      );\n    }\n\n    if (options.privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.privateKeyHexFromJwk(options.privateKeyJwk)\n      );\n    }\n\n    if (options.publicKeyJwk) {\n      publicKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.publicKeyHexFromJwk(options.publicKeyJwk)\n      );\n    }\n\n    return new Secp256k1KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L77\n    if (buffer[0] === 0xe7 && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new Secp256k1KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'EcdsaSecp256k1VerificationKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        keyUtils.publicKeyHexFromJwk(options.publicKeyJwk),\n        'hex'\n      );\n    } else {\n      throw new Error(\n        'Secp256k1KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.'\n      );\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    }\n\n    if (options.privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        keyUtils.privateKeyHexFromJwk(options.privateKeyJwk),\n        'hex'\n      );\n    }\n\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  publicNode() {\n    return this.toKeyPair(false);\n  }\n\n  signer() {\n    if (!this.privateKeyBuffer) {\n      throw new Error('No private key to sign with.');\n    }\n    let { privateKeyBuffer } = this;\n    return {\n      async sign({ data }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        const sigObj: any = secp256k1.ecdsaSign(\n          messageHashUInt8Array,\n          new Uint8Array(privateKeyBuffer)\n        );\n\n        return sigObj.signature;\n      },\n    };\n  }\n\n  verifier() {\n    if (!this.publicKeyBuffer) {\n      throw new Error('No public key to verify with.');\n    }\n    let { publicKeyBuffer } = this;\n    return {\n      async verify({ data, signature }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        let verified = false;\n        try {\n          verified = secp256k1.ecdsaVerify(\n            signature,\n            messageHashUInt8Array,\n            new Uint8Array(publicKeyBuffer)\n          );\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n\n  fingerprint() {\n    return Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: string) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let { publicKeyBuffer } = this;\n\n    // validate the first two multicodec bytes 0xe701\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'e701' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toJwk(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyJwkFromPrivateKeyHex(\n        this.privateKeyBuffer.toString('hex')\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyHex(\n      this.publicKeyBuffer.toString('hex')\n    );\n  }\n\n  async toHex(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyHexFromJwk(\n        await keyUtils.privateKeyJwkFromPrivateKeyHex(\n          this.privateKeyBuffer.toString('hex')\n        )\n      );\n    }\n    return keyUtils.publicKeyHexFromJwk(\n      await keyUtils.publicKeyJwkFromPublicKeyHex(\n        this.publicKeyBuffer.toString('hex')\n      )\n    );\n  }\n\n  toKeyPair(exportPrivate = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivate) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivate: boolean = false): any {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (exportPrivate) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n}\n","import base64url from 'base64url';\n\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\n\nimport {\n  ISecp256k1PrivateKeyJwk,\n  ISecp256k1PublicKeyJwk,\n  privateKeyUInt8ArrayFromJwk,\n  publicKeyUInt8ArrayFromJwk,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(Buffer.from(sigObj.signature));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  if (verified) {\n    return true;\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    // message: messageHashUInt8Array.toString('hex'),\n    // publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header: IJWSHeader = { alg: 'ES256K' }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(sigObj.signature);\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    message: messageHashUInt8Array.toString('hex'),\n    publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { MuiThemeProvider, createMuiTheme } from \"@material-ui/core/styles\";\n\nimport { darken, lighten } from \"@material-ui/core/styles/colorManipulator\";\n\nconst primaryColor = \"#594aa8\";\nconst secondaryColor = \"#fcb373\";\n\nconst font1 = '\"Rajdhani\"';\nconst font2 = '\"Roboto Condensed\"';\nconst font3 = '\"Lato\"';\n\nconst fontWeightLight = 300;\nconst fontWeightRegular = 400;\nconst fontWeightMedium = 600;\n\nclass Theme extends Component {\n  render() {\n    const { children } = this.props;\n    const theme = createMuiTheme({\n      splashImage: \"\",\n      palette: {\n        type: \"light\",\n        primary: {\n          light: lighten(primaryColor, 0.07),\n          main: primaryColor,\n          dark: darken(primaryColor, 0.07),\n        },\n        secondary: {\n          light: lighten(secondaryColor, 0.07),\n          main: secondaryColor,\n          dark: darken(secondaryColor, 0.07),\n        },\n      },\n      typography: {\n        useNextVariants: true,\n        fontSize: 16,\n        fontFamily: [font1, font2, font3].join(\",\"),\n        h1: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h2: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h3: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h4: {\n          fontFamily: font2,\n          textTransform: \"uppercase\",\n          letterSpacing: \"0.1em\",\n          fontWeight: fontWeightRegular,\n        },\n        h5: {\n          fontFamily: font2,\n          textTransform: \"uppercase\",\n          letterSpacing: \"0.1em\",\n          fontWeight: fontWeightRegular,\n        },\n        h6: {\n          fontFamily: font2,\n          textTransform: \"uppercase\",\n          letterSpacing: \"0.05em\",\n          fontWeight: fontWeightRegular,\n        },\n        subtitle1: {\n          fontFamily: font1,\n          fontWeight: fontWeightRegular,\n        },\n        subtitle2: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        body1: {\n          fontFamily: font3,\n          fontWeight: fontWeightRegular,\n        },\n        body2: {\n          fontFamily: font3,\n          fontWeight: fontWeightRegular,\n        },\n        button: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        caption: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        overline: {\n          fontFamily: font2,\n          letterSpacing: \"0.15em\",\n          textTransform: \"uppercase\",\n          fontWeight: fontWeightLight,\n        },\n      },\n\n      overrides: {\n        MuiInput: {\n          // Name of the component  / style sheet\n          input: {\n            fontFamily: font3,\n          },\n        },\n        MuiInputLabel: {\n          // Name of the component  / style sheet\n          root: {\n            fontFamily: font2,\n          },\n        },\n        MuiAppBar: {\n          root: {\n            // boxShadow: 'none',\n          },\n        },\n        MuiButton: {\n          // Name of the rule\n          contained: {\n            boxShadow: \"none\",\n          },\n        },\n      },\n    });\n    return <MuiThemeProvider theme={theme}>{children}</MuiThemeProvider>;\n  }\n}\n\nTheme.propTypes = {\n  children: PropTypes.any.isRequired,\n};\n\nexport default Theme;\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 660;","import {\n    documentLoaderFactory,\n    contexts,\n  } from \"@transmute/jsonld-document-loader\";\n  \n\n  import { driver as webCryptoDriver} from '@transmute/did-key-web-crypto'\n  \n  const golem = documentLoaderFactory.pluginFactory.build({\n    contexts: {\n      ...contexts.W3C_Decentralized_Identifiers,\n      ...contexts.W3C_Verifiable_Credentials,\n      ...contexts.W3ID_Security_Vocabulary,\n    },\n  });\n  \n  golem.addContext({\n    \"https://w3c-ccg.github.io/lds-jws2020/contexts/lds-jws2020-v1.json\": require(\"./lds-jws2020-v1.json\"),\n  });\n  \n  golem.addResolver({\n    'did:key:': {\n      resolve: async (uri) => {\n        const { didDocument } = await webCryptoDriver.resolve(uri, {\n          accept: 'application/did+json',\n        });\n        return didDocument;\n      },\n    },\n  })\n  \n  const documentLoader = golem.buildDocumentLoader();\n  \n  export { documentLoader };","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 917;"],"sourceRoot":""}